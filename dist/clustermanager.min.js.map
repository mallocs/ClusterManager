{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/ClusterManager.js","clustermanager.min.js","src/LazyMarker.js","src/utils.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","_interopRequireDefault","obj","__esModule","default","ClusterManager","map","opts","me","this","setMap","resetManager","setPrecision","zoomToPrecision","getZoom","google","maps","event","addDomListener","mapDragging","_onMapMoveEnd","markers","addMarkers","_utils","_LazyMarker","_LazyMarker2","window","prototype","OverlayView","onAdd","ready_","trigger","draw","clusters","cluster_fns","cluster_meta","precision","applyDefaults","padding","visualize","zoom_to_precision","zoom_level","cluster_by_distance","cluster_distance_factor","icon_color","current_precision_","clear","getMarkers","marker","getMarkerMeta","subtype","addToCluster","type","cluster","updateMarkers","getPrecision","getGeohash","lat","lng","Math","min","max","abs","max_power","latBase","parseInt","pow","toString","lngBase","fortyninezeros","latHash","substr","lngHash","geohash","geohashGetLatLngBounds","geohashGetPrecision","latMinHashBin","lngMinHashBin","fortynineones","latMaxHashBin","lngMaxHashBin","latMinHashDec","lngMinHashDec","latMaxHashDec","lngMaxHashDec","latMin","lngMin","latMax","lngMax","LatLngBounds","LatLng","undefined","getNeighborBoxes","box_str","boxString","bounds","boxString1","getSouthWest","boxString2","boxString3","getNorthEast","boxString4","boxString5","boxString6","boxString7","boxString8","boxStrings","neighbors","push","boxToPolygon","strokeColor","strokeWeight","strokeOpacity","fillColor","fillOpacity","ne","sw","polygon","Polygon","paths","boxInBounds","newBounds","getBounds","proj","getProjection","scale","pixelOffset","Point","nePoint","fromLatLngToPoint","swPoint","newNEPoint","x","y","newSWPoint","newNE","fromPointToLatLng","newSW","extend","boxBounds","contains","toSpan","Object","addMarker","raw_marker","defaults","hidden","visible","count","total","setClusterFn","createClusterMarker","summary","capType","charAt","toUpperCase","slice","getTitle","setMarkerMeta","count_type","markerLL","getLatLng","markerLat","latitude","markerLng","longitude","center","removeFromCluster","geoBox","test_marker","new_markers","center_lat","center_lng","combineBoxes","box_str1","box_str2","temp","combineClustersByDistance","clusterDistanceFactor","boxStr","neighborStr","distance","clusterCenter","j","result","neighborCenter","currentDist","geometry","spherical","computeDistanceBetween","cluster_markers","setVisible","meta","concat","err","final_markers","moveTimeout","clearTimeout","setTimeout","show","_showHide","hide","_lagUpdate","addListenerOnce","processingTimeout","reset","item","currentBounds","type_cluster","box","cluster_box","cluster_box_meta","fn","createClusterIcon","number","text_color","iconOpts","url","size","Size","anchor","shape","coord","createMarkerIconOpts","marker_list","manager","markerClickClosure","htmlEl","document","createElement","style","width","markerSpan","innerHTML","onclick","color","cursor","appendChild","createTextNode","icon","createMarker","position","title","content","zIndex","default_icon_color","./LazyMarker","./utils",2,"LazyMarker","_marker","addListener","defineProperty","value","_utils2","latitutde","getPosition","latlng",3,"index","_cluster_meta","height","cornerColor","baseUrl","iconUrl","replace","origin","Marker","iw","InfoWindow","now","Date","setZIndex","getTime","open"],"mappings":"CAAA,QAAAA,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,GAAA,kBAAAC,UAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EAAA,IAAAK,GAAA,GAAAC,OAAA,uBAAAN,EAAA,IAAA,MAAAK,GAAAE,KAAA,mBAAAF,EAAA,GAAAG,GAAAX,EAAAG,IAAAS,WAAAb,GAAAI,GAAA,GAAAU,KAAAF,EAAAC,QAAA,SAAAd,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,EAAAA,EAAAF,IAAAa,EAAAA,EAAAC,QAAAd,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAS,QAAA,IAAA,GAAAL,GAAA,kBAAAD,UAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAa,OAAAX,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAa,GAAA,SAAAT,EAAAU,EAAAJ,GCoCA,YCEA,SAASK,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAAWF,GDkCzF,QAASG,GAAeC,EAAKC,GACzB,GAAIC,GAAKC,IACTF,GAAOA,MACPE,KAAKH,IAAMA,EACXG,KAAKC,OAAOJ,GACZG,KAAKE,aAAaJ,GAClBE,KAAKG,aAAaH,KAAKI,gBAAgBJ,KAAKH,IAAIQ,YAChDC,OAAOC,KAAKC,MAAMC,eAAeZ,EAAK,YAAa,WAC/CE,EAAGW,aAAc,IAErBJ,OAAOC,KAAKC,MAAMC,eAAeZ,EAAK,UAAW,WAC7CE,EAAGW,aAAc,EACjBX,EAAGY,kBAEPL,OAAOC,KAAKC,MAAMC,eAAeZ,EAAK,iBAAkB,WAC/CE,EAAGW,aAAaX,EAAGY,kBAE5BL,OAAOC,KAAKC,MAAMC,eAAeZ,EAAK,eAAgB,WAClDE,EAAGY,kBAEqB,mBAAjBb,GAAKc,SAAyBZ,KAAKa,WAAWf,EAAKc,SChDlE,GAAIE,GAASjC,EDHiF,WCK1FkC,EAAclC,EDJK,gBCMnBmC,EAAexB,EAAuBuB,EDJ1CE,QAAOrB,eAAiBA,MAmDxBA,EAAesB,UAAY,GAAIZ,QAAOC,KAAKY,YAM3CvB,EAAesB,UAAUE,MAAQ,WAC7BpB,KAAKqB,QAAS,EACdf,OAAOC,KAAKC,MAAMc,QAAQtB,KAAM,WAMpCJ,EAAesB,UAAUK,KAAO,aAsBhC3B,EAAesB,UAAUhB,aAAe,SAASJ,GAC7CE,KAAKY,WACLZ,KAAKwB,YACLxB,KAAKyB,eACLzB,KAAK0B,eACL,IAAIC,GAAY7B,EAAK6B,WAAa,GAAK7B,EAAK6B,WAAa,GAAK7B,EAAK6B,UAAU,CAC7E7B,GAAOgB,EAhGHc,eAiGAC,QAA0B,IAC1BC,WAA0B,EAC1BC,kBAA0B,SAASC,GAC/B,MAAOA,GAAaL,GAExBM,qBAA0B,EAC1BC,wBAA0B,OAC1BC,WAA0B,UAC3BrC,GACHE,KAAKF,KAAOA,GAYhBF,EAAesB,UAAUf,aAAe,SAASwB,GAC7C,KAAGA,GAAa,IAAkB,EAAZA,GAAtB,CAGA,GAFA3B,KAAKoC,mBAAqBT,EAC1B3B,KAAKqC,QACmC,mBAA7BrC,MAAKwB,SAASG,GAErB,IAAI,GADAf,GAAUZ,KAAKsC,aACXxD,EAAE,EAAGO,EAAOuB,EAAQvB,OAAUA,EAAFP,EAAUA,IAAK,CAC/C,GAAIyD,GAAS3B,EAAQ9B,EACiB,aAAlCgC,EA9H0D0B,cA8H5CD,GAAQE,SACtBzC,KAAK0C,aAAaH,EAAQzB,EA/HgC0B,cA+HlBD,GAAQI,KAAMhB,GAIlE3B,KAAK4C,UACL5C,KAAK6C,kBAQTjD,EAAesB,UAAU4B,aAAe,WACpC,MAAO9C,MAAKoC,oBAoEhBxC,EAAesB,UAAU6B,WAAa,SAASC,EAAKC,EAAKtB,GAKrD,GAJAqB,EAAME,KAAKC,IAAIH,EAAK,IACpBA,EAAME,KAAKE,IAAIJ,EAAK,KACpBC,EAAMC,KAAKG,KAAKJ,EAAI,KAAO,KAAS,IAEnB,GAAbtB,EAAgB,MAAO,EAC3B,IAAI2B,GAAY,GAGZC,EAAUC,UAAUR,EAAM,IAASE,KAAKO,IAAI,GAAIH,IAAaI,SAAS,GACtEC,EAAUH,UAAUP,EAAM,KAAUC,KAAKO,IAAI,GAAIH,IAAaI,SAAS,GAEvEE,EAAiB,oDACjBC,EAAUD,EAAeE,OAAO,EAAG,GAAKP,EAAQlE,QAAUkE,EAC1DQ,EAAUH,EAAeE,OAAO,EAAG,GAAKH,EAAQtE,QAAUsE,EAG1DK,EAAUH,EAAQC,OAAO,EAAGnC,GAAaoC,EAAQD,OAAO,EAAGnC,EAC/D,OAAOqC,IASXpE,EAAesB,UAAU+C,uBAAyB,SAASD,GACvD,GAAIV,GAAY,GACZ3B,EAAY3B,KAAKkE,oBAAoBF,GACrCJ,EAAiB,oDACjBO,EAAgBH,EAAQF,OAAO,EAAGnC,GAAaiC,EAAeE,OAAO,EAAG,GAAKnC,GAC7EyC,EAAgBJ,EAAQF,OAAOnC,EAAWqC,EAAQ3E,QAClCuE,EAAeE,OAAO,EAAG,GAAKnC,GAC9C0C,EAAgB,oDAChBC,EAAgBN,EAAQF,OAAO,EAAGnC,GAAa0C,EAAcP,OAAO,EAAG,GAAKnC,GAC5E4C,EAAgBP,EAAQF,OAAOnC,EAAWqC,EAAQ3E,QAClCgF,EAAcP,OAAO,EAAG,GAAKnC,GAC7C6C,EAAgBhB,SAASW,EAAe,GACxCM,EAAgBjB,SAASY,EAAe,GACxCM,EAAgBlB,SAASc,EAAe,GACxCK,EAAgBnB,SAASe,EAAe,GACxCK,EAAS1B,KAAKE,IAAI,IAAQoB,EAAiBtB,KAAKO,IAAI,GAAIH,GAAc,IACtEuB,EAAS3B,KAAKE,IAAI,KAAQqB,EAAiBvB,KAAKO,IAAI,GAAIH,GAAc,KACtEwB,EAAS5B,KAAKC,IAAI,GAASuB,EAAgBxB,KAAKO,IAAI,GAAIH,GAAc,IACtEyB,EAAS7B,KAAKC,IAAI,IAAQwB,EAAiBzB,KAAKO,IAAI,GAAIH,GAAc,IAC1E,OAAO,IAAIhD,QAAOC,KAAKyE,aAAa,GAAI1E,QAAOC,KAAK0E,OAAOL,EAAQC,GAC/B,GAAIvE,QAAOC,KAAK0E,OAAOH,EAAQC,KAUvEnF,EAAesB,UAAUgD,oBAAsB,SAASF,GACpD,GAAIrC,GAAYqC,EAAQ3E,OAAS,CACjC,OAAImE,UAAS7B,KAAeA,GAAyB,EAAZA,GAAiBA,GAAa,GAAWuD,OAC3EvD,GAYX/B,EAAesB,UAAUiE,iBAAmB,SAASC,EAASzC,GAqB1D,IAAK,GAA2B0C,GApB5BC,EAAStF,KAAKiE,uBAAuBmB,GACrCzD,EAAY3B,KAAKkE,oBAAoBkB,GACrCG,EAAavF,KAAK+C,WAAWuC,EAAOE,eAAexC,MAAQ,KAC9BsC,EAAOE,eAAevC,MAAQ,KAAQtB,GACnE8D,EAAazF,KAAK+C,WAAWuC,EAAOE,eAAexC,MAAQ,KAC9BsC,EAAOE,eAAevC,MAAQ,KAAQtB,GACnE+D,EAAa1F,KAAK+C,WAAWuC,EAAOK,eAAe3C,MAAQ,KAC9BsC,EAAOK,eAAe1C,MAAQ,KAAQtB,GACnEiE,EAAa5F,KAAK+C,WAAWuC,EAAOK,eAAe3C,MAAQ,KAC9BsC,EAAOK,eAAe1C,MAAQ,KAAQtB,GACnEkE,EAAa7F,KAAK+C,WAAWuC,EAAOE,eAAexC,MAAQ,KAC9BsC,EAAOE,eAAevC,MAAQ,KAAQtB,GACnEmE,EAAa9F,KAAK+C,WAAWuC,EAAOE,eAAexC,MAAQ,KAC9BsC,EAAOE,eAAevC,MAAQ,KAAQtB,GACnEoE,EAAa/F,KAAK+C,WAAWuC,EAAOK,eAAe3C,MAAQ,KAC9BsC,EAAOK,eAAe1C,MAAQ,KAAQtB,GACnEqE,EAAahG,KAAK+C,WAAWuC,EAAOK,eAAe3C,MAAQ,KAC9BsC,EAAOK,eAAe1C,MAAQ,KAAQtB,GACnEsE,GAAcV,EAAYE,EAAYC,EAAYE,EAAYC,EAAYC,EAC5DC,EAAYC,GACrBlH,EAAI,EAAGoH,KAA2Bb,EAAYY,EAAWnH,GAAIA,IACT,mBAA9CkB,MAAKwB,SAASG,GAAWgB,GAAM0C,IAA8BA,IAAcD,GAClFc,EAAUC,KAAKd,EAGvB,OAAOa,IAiBXtG,EAAesB,UAAUkF,aAAe,SAASpC,EAASlE,GACtDA,EAAOgB,EArUHc,eAsUA/B,IAAgBG,KAAKH,IACrBwG,YAAgB,UAChBC,aAAgB,EAChBC,cAAgB,EAChBC,UAAgB,UAChBC,YAAgB,IACjB3G,EACH,IAAIwF,GAAStF,KAAKiE,uBAAuBD,GACrC0C,EAAKpB,EAAOK,eACZgB,EAAKrB,EAAOE,eACZoB,EAAU,GAAItG,QAAOC,KAAKsG,SAC1BC,MAAgBhH,EAAKgH,QAAUJ,EAAI,GAAIpG,QAAOC,KAAK0E,OAAOyB,EAAG1D,MAAO2D,EAAG1D,OAAQ0D,EAC9D,GAAIrG,QAAOC,KAAK0E,OAAO0B,EAAG3D,MAAO0D,EAAGzD,OAAQyD,GAC7DL,YAAgBvG,EAAKuG,YACrBC,aAAgBxG,EAAKwG,aACrBC,cAAgBzG,EAAKyG,cACrBC,UAAgB1G,EAAK0G,UACrBC,YAAgB3G,EAAK2G,YACrB5G,IAAgBC,EAAKD,KAEzB,OAAO+G,IAaXhH,EAAesB,UAAU6F,YAAc,SAAS/C,EAASsB,EAAQzD,GAE7D,GAAImF,GAAY,GAAI1G,QAAOC,KAAKyE,aAAahF,KAAKH,IAAIoH,YAAYzB,eACrBxF,KAAKH,IAAIoH,YAAYtB,eAClE,IAAuB,mBAAZ9D,GAAyB,CAChC,GAAIqF,GAAOlH,KAAKH,IAAIsH,gBAChBC,EAAQlE,KAAKO,IAAI,EAAGzD,KAAKH,IAAIQ,WAC7BgH,EAAc,GAAI/G,QAAOC,KAAK+G,MAAOzF,EAAUuF,GAAU,EAAGvF,EAAWuF,GAAU,GACjFG,EAAUL,EAAKM,kBAAkBlC,EAAOK,gBACxC8B,EAAUP,EAAKM,kBAAkBlC,EAAOE,gBACxCkC,EAAa,GAAIpH,QAAOC,KAAK+G,MAAMC,EAAQI,EAAIN,EAAYM,EACxBJ,EAAQK,EAAIP,EAAYO,GAC3DC,EAAa,GAAIvH,QAAOC,KAAK+G,MAAMG,EAAQE,EAAIN,EAAYM,EACxBF,EAAQG,EAAIP,EAAYO,GAC3DE,EAAQZ,EAAKa,kBAAkBL,GAC/BM,EAAQd,EAAKa,kBAAkBF,EACnCb,GAAUiB,OAAOH,GACjBd,EAAUiB,OAAOD,GAErB,GAAIE,GAAYlI,KAAKiE,uBAAuBD,EAC5C,OAAIgD,GAAUmB,SAASD,EAAUvC,iBAC7BqB,EAAUmB,SAASD,EAAU1C,iBACA,MAA7B0C,EAAUE,SAASpF,OAAsB,GACjC,GAUhBpD,EAAesB,UAAUL,WAAa,SAASD,EAAS+B,EAAMF,GAC1D,GAAgD,mBAA5C4F,OAAOnH,UAAUwC,SAAStE,KAAKwB,GAE/B,IAAI,GAAI9B,GAAE,EAAGO,EAAOuB,EAAQvB,OAAUA,EAAFP,EAAUA,IAAK,CAC/C,GAAIyD,GAAS3B,EAAQ9B,EACrBkB,MAAKsI,UAAU/F,GACXI,KAAYA,EACZF,QAAYA,MAsB5B7C,EAAesB,UAAUoH,UAAY,SAASC,EAAYzI,GAClC,mBAATA,KAAsBA,EAAOgB,EAta8B0B,cAsahB+F,GAEtD,IAAIhG,GAAS,GAAAvB,GAAA,WAAeuH,GAIxBC,GACA7F,KAAU,UACVF,QAAU,UACVgG,QAAU,EACVC,SAAU,EAEd5I,GAAOgB,EAlbHc,cAkbiB4G,EAAU1I,EAC/B,IAAI6C,GAAO7C,EAAK6C,KACZF,EAAU3C,EAAK2C,OAwBnB,IAtBkC,mBAAvBzC,MAAKY,QAAQ+B,KACpB3C,KAAKY,QAAQ+B,MACb3C,KAAK0B,aAAaiB,IACdgG,OACIC,MAAU,EACVF,QAAU,EACV9F,QAAU,KAIgB,mBAA3B5C,MAAKyB,YAAYkB,IACxB3C,KAAK6I,aAAalG,EAAM3C,KAAK8I,qBAGU,mBAAhC9I,MAAKY,QAAQ+B,GAAMF,KAC1BzC,KAAKY,QAAQ+B,GAAMF,OAEvBzC,KAAKY,QAAQ+B,GAAMF,GAAS0D,KAAK5D,GACjB,YAAZE,IACAzC,KAAK0B,aAAaiB,GAAa,MAAS,OAAK,EAC7C3C,KAAK0C,aAAaH,EAAQI,EAAM3C,KAAK8C,iBAEb,mBAAjBhD,GAAKiJ,QAAyB,CACrC,GAAIC,GAAUlJ,EAAK6C,KAAKsG,OAAO,GAAGC,cAAgBpJ,EAAK6C,KAAKwG,MAAM,EAClErJ,GAAKiJ,QAAuC,mBAAtBxG,GAAO6G,WAA6BJ,EAAU,WACrDhJ,KAAK2I,MAAM7I,EAAK6C,KAAM,SAAWJ,EAAO6G,WAE3DtI,EAjduDuI,cAidzC9G,EAAQzC,IAS1BF,EAAesB,UAAUyH,MAAQ,SAAShG,EAAM2G,GAC5C,MAAOtJ,MAAK0B,aAAaiB,GAAa,MAAE2G,IAa5C1J,EAAesB,UAAUwB,aAAe,SAASH,EAAQI,EAAMhB,EAAWqC,GACtE,GAAIxC,GAAWxB,KAAKwB,SAChB+H,EAAWhH,EAAOiH,YAClBC,EAAYF,EAASG,SACrBC,EAAYJ,EAASK,SACU,oBAAxBpI,GAASG,KAChBH,EAASG,OAE4B,mBAA9BH,GAASG,GAAWgB,KAC3BnB,EAASG,GAAWgB,MAExB,IAAIC,GAAUpB,EAASG,GAAWgB,EAIlC,IAHuB,mBAAZqB,KACPA,EAAUhE,KAAK+C,WAAW0G,EAAWE,EAAWhI,IAEpB,mBAArBiB,GAAQoB,GAA0B,CACzCpB,EAAQoB,GAAkB,QAAEmC,KAAK5D,EACjC,IAAIlD,GAASuD,EAAQoB,GAAkB,QAAE3E,OACrC2D,GAAQ3D,EAAS,GAAKA,EAAUuD,EAAQoB,GAAiB,OAAE,GAAKyF,EAAYpK,EAC5E4D,GAAQ5D,EAAS,GAAKA,EAAUuD,EAAQoB,GAAiB,OAAE,GAAK2F,EAAYtK,CAChFuD,GAAQoB,GAAiB,QAAKhB,EAAKC,OAEnCL,GAAQoB,IACJpB,SAAU,EACVhC,SAAW2B,GACXsH,QAAWJ,EAAWE,KAYlC/J,EAAesB,UAAU4I,kBAAoB,SAASvH,EAAQyB,GAC1D,GAAIrC,GAAY3B,KAAKkE,oBAAoBF,GACrCrB,EAAO7B,EA/gB2D0B,cA+gB7CD,GAAQI,KAC7BoH,EAAS/J,KAAKwB,SAASG,GAAWgB,GAAMqB,EAC5C,IAAiC,IAA7B+F,EAAgB,QAAE1K,aACXW,MAAKwB,SAASG,GAAWgB,GAAMqB,OACnC,IAAI+F,EAAgB,QAAE1K,OAAS,EAAG,CACrC,IAAK,GAAqD2K,GAAjDlL,EAAE,EAAGmL,KAAgBC,EAAW,EAAGC,EAAW,EAClDH,EAAcD,EAAgB,QAAEjL,GAAIA,IACjCkL,IAAgBzH,IAChB0H,EAAY9D,KAAK6D,GACjBE,GAA0BF,EAAYR,YAAYE,SAClDS,GAA0BH,EAAYR,YAAYI,UAG1DM,IAA0BD,EAAY5K,OACtC8K,GAA0BF,EAAY5K,OACtC0K,EAAe,QAAKG,EAAYC,GAChCJ,EAAgB,QAAIE,EACpBF,EAAgB,SAAI,EACpB/J,KAAKwB,SAASG,GAAWgB,GAAMqB,GAAW+F,IAYlDnK,EAAesB,UAAUkJ,aAAe,SAASC,EAAUC,EAAU3H,GACjE,GAAIhB,GAAY3B,KAAKkE,oBAAoBmG,EACzC,IAAIrK,KAAKwB,SAASG,GAAWgB,GAAM0H,GAAmB,QAAEhL,OACpDW,KAAKwB,SAASG,GAAWgB,GAAM2H,GAAmB,QAAEjL,OAAQ,CAC5D,GAAIkL,GAAOF,CACXA,GAAWC,EACXA,EAAWC,EAGf,IAAK,GAAoBhI,GADrBlD,EAASW,KAAKwB,SAASG,GAAWgB,GAAM2H,GAAmB,QAAEjL,OACxDP,EAAIO,EAAS,EAAWP,GAAK,EAAGA,IACrCyD,EAASvC,KAAKwB,SAASG,GAAWgB,GAAM2H,GAAmB,QAAExL,GAC7DkB,KAAK8J,kBAAkBvH,EAAQ+H,GAC/BtK,KAAK0C,aAAaH,EAAQI,EAAMhB,EAAW0I,IAWnDzK,EAAesB,UAAUsJ,0BAA4B,SAAS7H,GAC1D,GAAIhB,GAAY3B,KAAK8C,eACjBtB,EAAWxB,KAAKwB,SAChBiJ,EAAwBzK,KAAKF,KAAKoC,yBAA2B,MACjE,KAAK,GAAIwI,KAAUlJ,GAASG,GAAWgB,GAAO,CAe1C,IAAK,GAAuBgI,GAdxBzE,EAAYlG,KAAKmF,iBAAiBuF,EAAQ/H,GAC1CiI,EAAWH,EAAwBvH,KAAKO,IAAI,GAAI9B,EAAY,GAC5DkJ,EAAgBrJ,EAASG,GAAWgB,GAAM+H,GAAgB,OAYrDI,EAAI,EAAGC,EAAS,EAAgBJ,EAAczE,EAAU4E,GAAIA,IAAK,CACtED,EAAgBrJ,EAASG,GAAWgB,GAAM+H,GAAgB,MAC1D,IAAIM,GAAiBxJ,EAASG,GAAWgB,GAAMgI,GAAqB,OAChEM,EAAc3K,OAAOC,KAAK2K,SAASC,UAAUC,uBAC/B,GAAI9K,QAAOC,KAAK0E,OAAO4F,EAAc,GAAIA,EAAc,IACvD,GAAIvK,QAAOC,KAAK0E,OAAO+F,EAAe,GAAIA,EAAe,IACzDJ,GAAdK,IACAF,EAASD,EACTF,EAAWK,GAGfF,IACAJ,EAAczE,EAAU6E,GACxB/K,KAAKoK,aAAaM,EAAQC,EAAahI,MAanD/C,EAAesB,UAAU0B,QAAU,SAASD,GACxC,GACInB,GACAe,EACA8I,EACAvM,EAJA6C,EAAY3B,KAAK8C,cAKrB,IAAoB,mBAATH,IAOX,GAAkC,mBAAvB3C,MAAKY,QAAQ+B,GAAxB,CACA,GAA6C,mBAAlC3C,MAAKY,QAAQ+B,GAAe,QACnC,IAAK7D,EAAI,EAAGyD,EAAQA,EAASvC,KAAKY,QAAQ+B,GAAe,QAAE7D,GAAIA,IAC3DyD,EAAO+I,YAAW,EAG1BtL,MAAKY,QAAQ+B,GAAe,WAC5B3C,KAAK0B,aAAaiB,GAAa,MAAW,QAAI,EAC9CnB,EAAWxB,KAAKwB,SACZxB,KAAKF,KAAKmC,qBAAqBjC,KAAKwK,0BAA0B7H,EAClE,KAAK,GAAI+H,KAAUlJ,GAASG,GAAWgB,GAAO,CAEtC3C,KAAKF,KAAKgC,WAAW9B,KAAKoG,aAAasE,GAAQzK,OAAOD,KAAKH,IAC/D,IAAI+C,GAAUpB,EAASG,GAAWgB,GAAM+H,EACxC,KAAK5L,EAAI,EAAGuM,KAAsB9I,EAASK,EAAiB,QAAE9D,GAAIA,IAAK,CACnE,GAAIyM,GAAOzK,EA7oBmD0B,cA6oBrCD,EACE,oBAAhBgJ,GAAK9C,QAA2B8C,EAAK9C,QAC5C4C,EAAgBlF,KAAK5D,GAGzB8I,EAAgBhM,OAAS,GACzBuD,EAAiB,QAAI5C,KAAKyB,YAAYkB,GAAM0I,EAAiBzI,EAAgB,OAAE,GACnCA,EAAgB,OAAE,GAAI5C,MAClEA,KAAKsI,UAAU1F,EAAiB,SAC5BD,KAAUA,EACVF,QAAU,UACVgG,QAAU,IAEdzI,KAAK0B,aAAaiB,GAAa,MAAW,SAAK,GAE/CC,EAAiB,SAAI,QArC7B,CACIpB,EAAWxB,KAAKwB,SAASG,EACzB,KAAKgB,IAAQnB,GACTxB,KAAK4C,QAAQD,KAgDzB/C,EAAesB,UAAUoB,WAAa,SAASK,EAAMF,EAASiG,GAC1D,GAAI9H,KACJ,IAAIZ,KAAKY,aAAgB,QACzB,IAAoB,mBAAT+B,GACP,IAAKA,IAAQ3C,MAAKY,QACd,IAAK6B,IAAWzC,MAAKY,QAAQ+B,GACzB/B,EAAUA,EAAQ4K,OAAOxL,KAAKY,QAAQ+B,GAAMF,QAGjD,IAAuB,mBAAZA,GACd,IAAKA,IAAWzC,MAAKY,QAAQ+B,GAEzB/B,EAAUA,EAAQ4K,OAAOxL,KAAKY,QAAQ+B,GAAMF,QAGhD,KACI7B,EAAUZ,KAAKY,QAAQ+B,GAAMF,OAC/B,MAAOgJ,GACL7K,KAGR,GAAuB,mBAAZ8H,GAAyB,MAAO9H,EAE3C,KAAK,GAAI9B,GAAE,EAAG4M,KAAkBrM,EAAOuB,EAAQvB,OAAUA,EAAFP,EAAUA,IAAK,CAClE,GAAIyD,GAAS3B,EAAQ9B,GACjByM,EAAOzK,EAnsBuD0B,cAmsBzCD,IACT,QAAZmG,GAAqB6C,EAAK9C,SAAWC,GAAW6C,EAAK7C,UAAYA,GAC/C,kBAAXnG,IAAuC,YAAdgJ,EAAK5I,OACrC+I,EAAcvF,KAAK5D,GAG3B,MAAOmJ,IAQX9L,EAAesB,UAAUP,cAAgB,WACrC,GAAIZ,GAAKC,IACqB,oBAAnBD,GAAG4L,cACVC,aAAa7L,EAAG4L,mBACT5L,GAAG4L,YAEd,IAAIhK,GAAY5B,EAAGK,gBAAgBL,EAAGF,IAAIQ,UACtCN,GAAG+C,iBAAmBnB,EACtB5B,EAAGI,aAAawB,GAEhB5B,EAAG4L,YAAcE,WAAW,iBACjB9L,GAAG4L,YACV5L,EAAG8C,iBACJ,MAUXjD,EAAesB,UAAU4K,KAAO,SAASnJ,EAAMF,GAC3CzC,KAAK+L,UAAUpJ,EAAMF,GAAS,IASlC7C,EAAesB,UAAU8K,KAAO,SAASrJ,EAAMF,GAC3CzC,KAAK+L,UAAUpJ,EAAMF,GAAS,IAOlC7C,EAAesB,UAAU6K,UAAY,SAASpJ,EAAMF,EAASuJ,GAGzD,IAAI,GAFAjM,GAAKC,KACLY,EAAUZ,KAAKsC,WAAWK,EAAMF,GAC5B3D,EAAE,EAAGO,EAAOuB,EAAQvB,OAAUA,EAAFP,EAAUA,IAAK,CAC/C,GAAIyD,GAAS3B,EAAQ9B,EACrBgC,GA/vBkE0B,cA+vBpDD,GAAQkG,OAASuD,EAE/BhM,KAAKqB,OAAQrB,KAAKiM,WAAWtJ,GAE7BrC,OAAOC,KAAKC,MAAM0L,gBAAgBlM,KAAM,SAAU,WAC9CD,EAAGkM,WAAWtJ,MAW1B/C,EAAesB,UAAU+K,WAAa,SAAStJ,GAC3C,GAAI5C,GAAKC,IAC6B,oBAA3BA,MAAKmM,oBACZP,aAAa7L,EAAGoM,yBACTpM,GAAGoM,mBAEdnM,KAAKmM,kBAAoBN,WAAW,iBACzB9L,GAAGoM,kBACVpM,EAAGsC,MAAMM,GACT5C,EAAG6C,QAAQD,GACX5C,EAAG8C,iBACJ,MAQPjD,EAAesB,UAAUkL,MAAQ,SAASzJ,GACtC,GAAmB,mBAATA,GAAV,CAOA3C,KAAKqC,MAAMM,EAEX,KAAI,GAAIhB,KAAa3B,MAAKwB,eACfxB,MAAKwB,SAASG,GAAWgB,GAChC3C,KAAKwB,SAASG,GAAWgB,YAEtB3C,MAAKY,QAAQ+B,GACpB3C,KAAKY,QAAQ+B,UAdb,CACI,GAAInB,GAAWxB,KAAKwB,SAASxB,KAAK8C,eAClC,KAAIH,IAAQnB,GACRxB,KAAKoM,MAAMzJ,KAqBvB/C,EAAesB,UAAUmB,MAAQ,SAASM,GAEtC,IAAI,GADA/B,GAAUZ,KAAKsC,WAAWK,GACtB7D,EAAE,EAAGO,EAAOuB,EAAQvB,OAAUA,EAAFP,EAAUA,IAAK,CAC/C,GAAIyD,GAAS3B,EAAQ9B,EACrByD,GAAOtC,OAAO,MACda,EAh0BkE0B,cAg0BpDD,GAAQmG,SAAU,EAEpC,GAAoB,mBAAT/F,IAAwB3C,KAAK0B,cAAgB1B,KAAK0B,aAAaiB,GACtE3C,KAAK0B,aAAaiB,GAAa,MAAW,QAAI,MAE9C,KAAK,GAAI0J,KAAQrM,MAAK0B,aAClB1B,KAAK0B,aAAa2K,GAAa,MAAW,QAAI,GAW1DzM,EAAesB,UAAUd,gBAAkB,SAAS4B,GAChD,MAAOhC,MAAKF,KAAKiC,kBAAkBC,IAOvCpC,EAAesB,UAAU2B,cAAgB,WACrC,GAAIN,GACAgJ,EACAlM,EACAP,EACA6C,EAAY3B,KAAK8C,eACjBwJ,EAAgBtM,KAAKH,IAAIoH,YACzBrE,EAAU5C,KAAKwB,SAASG,EAC5B,KAAK,GAAIgB,KAAQC,GAAS,CACtB,GAAI2J,GAAe3J,EAAQD,EAC3B,KAAK,GAAI6J,KAAOD,GAAc,CAC1B,GAAIE,GAAcF,EAAaC,GAC3BE,EAAmB5L,EAr2BuC0B,cAq2BzBiK,EAAqB,QAC1D,IAAIzM,KAAK+G,YAAYyF,EAAKF,EAAetM,KAAKF,KAAK+B,SAC/C,GAAI4K,EAAqB,SACrB,IAAKC,EAAiBjE,SAAWiE,EAAiBhE,QAAS,CACvD,IAAI5J,EAAE,EAAGO,EAAOoN,EAAqB,QAAEpN,OAAUA,EAAFP,EAAUA,IACrDyD,EAASkK,EAAqB,QAAE3N,GAChCgC,EA32B8C0B,cA22BhCD,GAAQmG,SAAU,CAEpC+D,GAAqB,QAAExM,OAAOD,KAAKH,KACnC4M,EAAqB,QAAEnB,YAAW,GAClCoB,EAAiBhE,SAAU,EAC3B1I,KAAK0B,aAAaiB,GAAa,MAAW,SAAK,OAGnDJ,GAASkK,EAAqB,QAAE,GAChClB,EAAOzK,EAp3B+C0B,cAo3BjCD,GAChBgJ,EAAK9C,QAAW8C,EAAK7C,UACtBnG,EAAOtC,OAAOD,KAAKH,KACnB0C,EAAO+I,YAAW,GAClBC,EAAK7C,SAAU,EACf1I,KAAK0B,aAAaiB,GAAa,MAAW,SAAK,OAIvD,IAAI8J,EAAqB,QACrBA,EAAqB,QAAEnB,YAAW,GAC9BoB,EAAiBhE,UAAS1I,KAAK0B,aAAaiB,GAAa,MAAW,SAAK,GAC7E+J,EAAiBhE,SAAU,MAE3B,KAAI5J,EAAE,EAAGO,EAAOoN,EAAqB,QAAEpN,OAAUA,EAAFP,EAAUA,IACrDyD,EAASkK,EAAqB,QAAE3N,GAChCyM,EAAOzK,EAp4B2C0B,cAo4B7BD,GACrBA,EAAO+I,YAAW,GACdC,EAAK7C,UAAS1I,KAAK0B,aAAaiB,GAAa,MAAW,SAAK,GACjE4I,EAAK7C,SAAU,KAgBvC9I,EAAesB,UAAU2H,aAAe,SAASlG,EAAMgK,GACnD3M,KAAKyB,YAAYkB,GAAQgK,GAc7B/M,EAAesB,UAAU0L,kBAAoB,SAASC,EAAQlL,EAAWQ,EAAY2K,GACjF,GAAIC,EAEJ,IADAD,EAAaA,GAAc,SACvBnL,EAAY,GACZoL,GACIC,IAAS,0EACCH,EAAS,8BAAgC1K,EAAa,UAAY2K,EAClE,2CACVG,KAAS,GAAI3M,QAAOC,KAAK2M,KAAK,GAAI,SAEnC,CACH,GAAID,GAAoC,IAA3BJ,EAAS,IAAIxN,OAAS,GAAS,EAC5C0N,IACIE,KAAW,GAAI3M,QAAOC,KAAK2M,KAAKD,EAAMA,GACtCE,OAAW,GAAI7M,QAAOC,KAAK+G,MAAM2F,EAAK,EAAGA,EAAK,GAC9CG,OACIC,OAASJ,EAAK,EAAGA,EAAK,EAAGA,EAAK,GAC9BtK,KAAQ,UAEZqK,IAAW,iDAAmDC,EAAO,IAAMA,EAChE,SAAW9K,EAAa,0BAA4B0K,EAAS,QAC5DC,EAAa,iCAGjC,MAAO9M,MAAKsN,qBAAqBP,IAYrCnN,EAAesB,UAAU4H,oBAAsB,SAASyE,EAAarD,EAAYC,EAAYqD,GAIzF,QAASC,GAAmBlL,GACxB,MAAO,UAASlE,GACZiC,OAAOC,KAAKC,MAAMc,QAAQiB,EAAQ,QAASlE,IALnD,GAAIqP,GAASC,SAASC,cAAc,MACpCF,GAAOG,MAAMC,MAAQ,OAOrB,KAAK,GAAWvL,GAAPzD,EAAI,EAAWyD,EAASgL,EAAYzO,GAAIA,IAAK,CAClD,GAAIiP,GAAaJ,SAASC,cAAc,OAMxC,IALAG,EAAWC,UAAY,MAAQlN,EAr9BmC0B,cAq9BrBD,GAAQwG,QAAU,WAC/DgF,EAAWE,QAAUR,EAAmBlL,GACxCwL,EAAWF,MAAMK,MAAQ,UACzBH,EAAWF,MAAMM,OAAS,UAC1BT,EAAOU,YAAYL,GACfjP,GAAK,EAAG,MAEZyO,EAAYlO,OAAS,IACrBqO,EAAOU,YAAYT,SAASU,eAAgBd,EAAYlO,OAAS,GAC9C,oDAEvB,IAAI8C,GAAaqL,EAAQ1N,KAAKqC,WAAWrB,EAh+B6B0B,cAg+Bf+K,EAAY,IAAI5K,OACR6K,EAAQ1N,KAAKqC,WACxEmM,EAAOd,EAAQZ,kBAAkBW,EAAYlO,OAAQmO,EAAQ1K,eAAgBX,EAUjF,OATAI,GAASiL,EAAQe,cACbC,SAAa,GAAIlO,QAAOC,KAAK0E,OAAOiF,EAAYC,GAChDsE,MAAalB,EAAYlO,OAAS,WAClCqP,QAAahB,EACb3E,QAAawE,EAAYlO,OAAS,WAClCiP,KAAaA,EACblB,MAAakB,EAAY,MACzBK,OAAapB,EAAYlO,UAkBjCO,EAAesB,UAAUoM,qBAAuB,SAASxN,GACjC,mBAATA,KAAsBA,KAEjC,IAAI8O,GAAqB,QASzB,OARyB,mBAAd5O,MAAKF,MAAwD,mBAAzBE,MAAKF,KAAKqC,aACjB,gBAAzBnC,MAAKF,KAAKqC,WACjByM,EAAqB5O,KAAKF,KAAKqC,WACQ,gBAAzBnC,MAAKF,KAAKqC,YAAgD,mBAAdrC,GAAK6C,MAAmE,gBAApC3C,MAAKF,KAAKqC,WAAWrC,EAAK6C,QACxHiM,EAAqB5O,KAAKF,KAAKqC,WAAWrC,EAAK6C,QAIhD7B,EAxgCYwM,qBAwgCSxM,EAxgCxBc,eAwgCuCO,WAAYyM,GAAqB9O,KAgBhFF,EAAesB,UAAUqN,aAAe,SAASzO,GAC7C,MAAOgB,GAzhCkCyN,aAyhCrBvO,KAAKH,IACLiB,EA1hChBc,eA0hC+B0M,KAAMtO,KAAKsN,qBAAqBxN,IAAQA,OC/B5E+O,eAAe,EAAEC,UAAU,IAAIC,GAAG,SAASlQ,EAAQU,EAAOJ,GCpiC7D,YD0iCA,SAASK,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAAWF,GCriCzF,QAASuP,GAAWzG,GAChBvI,KAAKuI,WAAaA,EAEdvI,KAAKiP,QADwB,kBAAtB1G,GAAWtI,OACHsI,EAEA,KAEnBjI,OAAOC,KAAKC,MAAM0O,YAAYlP,KAAM,QAAS,SAAU3B,GAC/C2B,KAAKiP,SACL3O,OAAOC,KAAKC,MAAMc,QAAQtB,KAAKiP,QAAS,QAAS5Q,KDwhC7DgK,OAAO8G,eAAehQ,EAAS,cAC3BiQ,OAAO,GAKX,IAAItO,GAASjC,EC3iCa,WD6iCtBwQ,EAAU7P,EAAuBsB,EC3hCrCkO,GAAW9N,UAAUjB,OAAS,SAAUJ,GACpC,GAAIG,KAAKiP,QAEL,WADAjP,MAAKiP,QAAQhP,OAAOJ,EAGxB,IAAKA,EAAL,CAEA,GAAI2I,IACAiG,MAAOzO,KAAKuI,WAAWkG,MACvB9L,MAAM,EACNF,QAAS,GACTiM,QAAS,IAET5O,EAAOuP,EAAA,WAAc7G,EAAUxI,KAAKuI,WAExCvI,MAAKiP,QAAUrP,eAAesB,UAAUqN,cACpCE,MAAO3O,EAAK2O,MACZ9L,KAAM7C,EAAK6C,KACX+L,QAAS5O,EAAK4O,QACdF,SAAU,GAAIlO,QAAOC,KAAK0E,OAAOnF,EAAKwP,UACNxP,EAAK8J,WACrCnH,QAAS3C,EAAK2C,UAGlBzC,KAAKiP,QAAQhP,OAAOJ,KAGxBmP,EAAW9N,UAAUqO,YAAc,WAC/B,GAAIvP,KAAKiP,SAAWjP,KAAKiP,QAAQM,cAC7B,MAAOvP,MAAKiP,QAAQM,aAExB,IAAIC,GAASxP,KAAKwJ,WAElB,OADAxJ,MAAKuI,WAAWiG,SAAW,GAAIlO,QAAOC,KAAK0E,OAAOuK,EAAOF,UAAWE,EAAO5F,WACpE5J,KAAKuI,WAAWiG,UAG3BQ,EAAW9N,UAAUsI,UAAY,WAM7B,MALIxJ,MAAKiP,SAA+C,mBAA7BjP,MAAKuI,WAAWmB,WACvC1J,KAAKuI,WAAWiG,SAAWxO,KAAKiP,QAAQM,cACxCvP,KAAKuI,WAAWmB,SAAW1J,KAAKuI,WAAWiG,SAASxL,MACpDhD,KAAKuI,WAAWqB,UAAY5J,KAAKuI,WAAWiG,SAASvL,QAGrDyG,SAAU1J,KAAKuI,WAAWmB,SAC1BE,UAAW5J,KAAKuI,WAAWqB,YAInCoF,EAAW9N,UAAUkI,SAAW,WAC5B,MAAQpJ,MAAKiP,SAAWjP,KAAKiP,QAAQ7F,YAAepJ,KAAKuI,WAAWkG,OAGxEO,EAAW9N,UAAUoK,WAAa,SAAU5C,GACxC1I,KAAKiP,SAAWjP,KAAKiP,QAAQ3D,WAAW5C,IDgjC5CvJ,EAAQ,WC5iCO6P,ED+iCfzP,EAAOJ,QAAUA,EAAQ,aAEtB2P,UAAU,IAAIW,GAAG,SAAS5Q,EAAQU,EAAOJ,GE7nC5C,YAWQ,SAASyC,GAAc4G,EAAU1I,GACrC,GAAwB,gBAAb0I,GAAuB,QAClC,IAAoB,gBAAT1I,GAAmB,MAAO0I,EACrC,KAAK,GAAIkH,KAASlH,GACa,mBAAhB1I,GAAK4P,KACZ5P,EAAK4P,GAASlH,EAASkH,GAG/B,OAAO5P,GASJ,QAASuJ,GAAc9G,EAAQgJ,GAClC,GAAI/C,GAAW5G,EAAc2J,EAAMhJ,EAAOoN,cAC1CpN,GAAOoN,cAAgB/N,EAAc4G,EAAU+C,GAS3C,QAAS/I,GAAcD,GAC3B,IACI,MAAOA,GAAOoN,cAChB,MAAOlE,GAEL,MADAlJ,GAAOoN,iBACApN,EAAOoN,eAiBf,QAASrC,GAAqBxN,GACb,mBAATA,KAAsBA,MACP,mBAAfA,GAAKgO,QAAuBhO,EAAKgO,MAAQ,IACzB,mBAAhBhO,GAAK8P,SAAwB9P,EAAK8P,OAAS,GACtD,IAAI9B,GAAQhO,EAAKgO,MACb8B,EAAS9P,EAAK8P,OAEdzN,EAAa,QAOc,oBAApBrC,GAAKqC,aACmB,gBAApBrC,GAAKqC,WACZA,EAAarC,EAAKqC,WACgB,gBAApBrC,GAAKqC,YAAgD,mBAAdrC,GAAK6C,MAA8D,gBAA/B7C,GAAKqC,WAAWrC,EAAK6C,QAC9GR,EAAarC,EAAKqC,WAAWrC,EAAK6C,QAIV,mBAArB7C,GAAKuG,cAA6BvG,EAAKuG,YAAc,UAChC,mBAArBvG,GAAK+P,cAA6B/P,EAAK+P,YAAc,SAChE,IAAIC,GAAU,4CACVC,EAAUD,EAAU,QAAUhC,EAAQ,IAAM8B,EAAS,SAC5C9P,EAAK+P,YAAYG,QAAQ,IAAK,IAAM,IAAM7N,EAAa,IACvDrC,EAAKuG,YAAY2J,QAAQ,IAAK,IAAM,WAEjD,OAAOpO,IACHoL,IAAS+C,EACT9C,KAAS,GAAI3M,QAAOC,KAAK2M,KAAKY,EAAO8B,GACrCK,OAAS,GAAI3P,QAAOC,KAAK+G,MAAM,EAAG,GAClC6F,OAAS,GAAI7M,QAAOC,KAAK+G,MAAMwG,EAAM,EAAG8B,IACzC9P,GAiBC,QAASyO,GAAa1O,EAAKC,GAE/B,GAAI0I,IACA3I,IAAUA,EACV6I,SAAU,EACV4F,KAAUhB,EAAqBxN,GAC/B4O,QAAU,SAEd5O,GAAO8B,EAAc4G,EAAU1I,EAC/B,IAAIyC,GAAS,GAAIjC,QAAOC,KAAK2P,OAAOpQ,EACpC,IAAuB,mBAAZA,GAAK6M,GAAoB,CAChC,GAAIwD,GAAK,GAAI7P,QAAOC,KAAK6P,YACrB1B,QAAS5O,EAAK4O,SAElBpO,QAAOC,KAAKC,MAAM0O,YAAY3M,EAAQ,QAAS,WAC3C,GAAI8N,GAAM,GAAIC,KACdH,GAAGI,UAAUF,EAAIG,WACjBL,EAAGM,KAAK5Q,EAAK0C,SAGjBjC,QAAOC,KAAKC,MAAM0O,YAAY3M,EAAQ,QAASzC,EAAK6M,GAGxD,OADAtD,GAAc9G,EAAQzC,GACfyC,EFy/BX8F,OAAO8G,eAAehQ,EAAS,cAC3BiQ,OAAO,IAEXjQ,EExnCiByC,cAAAA,EFynCjBzC,EExmCgBkK,cAAAA,EFymChBlK,EE9lCiBqD,cAAAA,EF+lCjBrD,EEzkCgBmO,qBAAAA,EF0kChBnO,EEvhCiBoP,aAAAA,YFoqCN","file":"clustermanager.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/****\n* mallocs media industries\n* http://www.mallocs.net\n****/  \n\n\n/************************************************************************************************\n * Cluster Manager\n ************************************************************************************************/\n\n/**\n * @name ClusterManager\n * @version 2.0\n * @author Marcus Ulrich\n * @fileoverview\n * This library creates and manages clusters for Google Maps API v3. It does two things to make maps \n * with large numbers of markers more useable: 1) Combines markers in close proximity to each other \n * based on zoom level into clusters, 2) Only adds markers in the current viewport (and optional \n * padding) to the map.\n * <b>How it works</b>:<br/>\n * The manager sets up a dictionary for clusters and a dictionary for markers. Every marker that's \n * added to the manager has a string created based on it's latitude, longitude, and zoom level and \n * that's used to add it to the cluster dictionary. Nearby markers will hash to the same string so \n * nothing has to be calculated. Nearby clusters are then combined.\n * Markers can be added with optional type and subtypes so subsets of markers can be shown and \n * hidden. Markers with the same subtype will still be clustered together, but can be shown or \n * hidden seperately. Markers with the same type will be clustered together and can also be hidden\n * or shown seperately.\n * The function used to create the clusters is stored and this function can be overridden for \n * greater control of the look and/or behavior of the clusters for each marker type.\n */\n \n/***************************************************************************************************\n * Cluster Manager\n **************************************************************************************************/\n\n'use strict';\n\n//var LazyMarker = window.LazyMarker;\n//var applyDefaults = require(\"./utils\");\n//var LazyMarker = require(\"./LazyMarker\");\nimport {applyDefaults, createMarkerIconOpts, createMarker, setMarkerMeta, getMarkerMeta} from \"./utils\";\nimport LazyMarker from \"./LazyMarker\"; \n\nwindow.ClusterManager = ClusterManager || {};\n\n/**\n * Creates a new Cluster Manager for clustering markers on a V3 Google map.\n *\n * @param {GMap3} map The map that the markers should be added to.\n * @param {object} [opts] Options for configuring the behavior of the clustering. Defaults are \n * applied in resetManager.\n * @param {google.maps.Marker[]} [opts.markers] Markers to add to the manager.\n * @param {function} [opts.zoom_to_precision=function(zoom_level) {return zoom_level + precision;}] \n * A function to set the precision for each zoom level. \n * @param {number} [opts.precision=2] A number between 0 and 27 that sets how small the cluster \n * boxes will be. Higher numbers will make smaller boxes.\n * @param {string|object} [opts.icon_color=\"00CC00\"] Sets the default icon color in HEX. Default is \n * a bright green.\n * @param {number} [opts.padding=200] The amount of padding in pixels where markers not in the \n * viewport will still be added to the map.\n * @param {boolean} [opts.visualize=false] For debugging. Will put a box around each cluster with at \n * least one marker.\n * @param {number} [opts.cluster_by_distance=true] Combine neighboring clusters if they are close \n * together. This is a little slower but makes more rounded clusters.\n * @param {number} [opts.cluster_distance_factor=2048000] Clusters are combined if they are within \n * this distance: cluster_distance_factor*Math.pow(2, -precision+2)\n * @constructor\n */\n\n\n     \nfunction ClusterManager(map, opts) {\n    var me = this;\n    opts = opts || {};\n    this.map = map;\n    this.setMap(map);\n    this.resetManager(opts);\n    this.setPrecision(this.zoomToPrecision(this.map.getZoom()));\n    google.maps.event.addDomListener(map, \"dragstart\", function() {\n        me.mapDragging = true;\n    });\n    google.maps.event.addDomListener(map, \"dragend\", function() {\n        me.mapDragging = false;\n        me._onMapMoveEnd();\n    });\n    google.maps.event.addDomListener(map, \"center_changed\", function() {\n        if (!me.mapDragging) me._onMapMoveEnd();\n    });\n    google.maps.event.addDomListener(map, \"zoom_changed\", function() {\n        me._onMapMoveEnd();\n    });\n    if (typeof opts.markers !== \"undefined\") this.addMarkers(opts.markers);\n}\n\nClusterManager.prototype = new google.maps.OverlayView();\n/**\n * @ignore\n * This is implemented only so we can tell when the map is ready and to get the custom overlay \n * functionality.\n */\nClusterManager.prototype.onAdd = function() {\n    this.ready_ = true;\n    google.maps.event.trigger(this, \"ready_\");\n};\n\n/**\n * @ignore\n */\nClusterManager.prototype.draw = function() {};\n\n/**\n * Sets the marker and clusters back to the inital state.\n *\n * @param {object} [opts] Options for configuring the behavior of the clustering. Defaults are \n * applied in resetManager.\n * @param {function} [opts.zoom_to_precision=function(zoom_level) {return zoom_level + precision;}] \n * A function to set the precision for each zoom level. \n * @param {number} [opts.precision=2] A number between 0 and 27 that sets how small the cluster \n * boxes will be. Higher numbers will make smaller boxes.\n * @param {string|object} [opts.icon_color=\"00CC00\"] Sets the default icon color in HEX. Default is \n * a bright green.\n * @param {number} [opts.padding=200] The amount of padding in pixels where markers not in the \n * viewport will still be added to the map.\n * @param {boolean} [opts.visualize=false] For debugging. Will put a box around each cluster with at \n * least one marker.\n * @param {number} [opts.cluster_by_distance=true] Combine neighboring clusters if they are close \n * together. This is a little slower but makes more rounded clusters.\n * @param {number} [opts.cluster_distance_factor=2048000] Clusters are combined if they are within \n * this distance: cluster_distance_factor*Math.pow(2, -precision+2)\n */\nClusterManager.prototype.resetManager = function(opts) {\n    this.markers = {}; //hold markers by type, then subtype.\n    this.clusters = {}; //define clusters by precision, type, then geobox.\n    this.cluster_fns = {}; //store cluster function for building the cluster markers.\n    this.cluster_meta = {}; //marker counts, etc\n    var precision = opts.precision >= 0 && opts.precision <= 27 ? opts.precision:2;\n    opts = applyDefaults({\n        padding                 : 200,\n        visualize               : false,\n        zoom_to_precision       : function(zoom_level) {\n            return zoom_level + precision;\n        },\n        cluster_by_distance     : true,\n        cluster_distance_factor : 2048000,\n        icon_color              : \"00CC00\"\n    }, opts);\n    this.opts = opts;\n};\n\n/**\n * Sets the current level of precision.\n * To speed up clustering and reduce memory, only the clusters for the current precision are \n * calculated so changing the precision may take extra time to calculate clusters at the new \n * precision.\n *\n * @param {number} precision The level to set the precision to. Currently, must be from 1 to 49.\n * @private\n */\nClusterManager.prototype.setPrecision = function(precision) {\n    if(precision >= 50 || precision < 0) return;\n    this.current_precision_ = precision;\n    this.clear();\n    if (typeof this.clusters[precision] === \"undefined\") {\n        var markers = this.getMarkers();\n        for(var i=0, length=markers.length; i<length; i++) { \n            var marker = markers[i];\n            if (getMarkerMeta(marker).subtype !== \"cluster\") {\n                this.addToCluster(marker, getMarkerMeta(marker).type, precision);\n            }\n        }\n    }\n    this.cluster();\n    this.updateMarkers();\n};\n\n/**\n * Gets the current precision of the clusterer.\n *\n * @returns {number} The current precision.\n */\nClusterManager.prototype.getPrecision = function() {\n    return this.current_precision_;\n};\n\n/**\n * Gets a hash based on latitude, longitude and precision. Higher precisions are geographically \n * smaller areas. \n * Since distance between degrees of longitude varies based on latitude: \n *     (pi/180)*(6,378,137.0 meters)cos(degrees latitude)\n * the area covered by a given geohash precision will get smaller as it approaches the poles \n * (cos(90 degrees) = 0). \n * If you visualize the boxes, however, they will look larger based on the map projection.\n * The chart below shows the width covered by a given geohash at each precision level using 49 bits.\n * prec width\t\twidth of lat\n * \t(lat/lng)\t(meters)\n * 2\t140.737488\t15666825.5392391m\n * 3\t70.3687443\t7833412.76961958m\n * 4\t35.1843720\t3916706.3848097343m\n * 5\t17.5921860\t1958353.1924048115m\n * 6\t8.79609302\t979176.5962023503m\n * 7\t4.39804651\t489588.2981011198m\n * 8\t2.19902325\t244794.14905050377m\n * 9\t1.09951162\t122397.07452519651m\n * 10\t0.54975581\t61198.53726254289m\n * 11\t0.27487790\t30599.268631216073m\n * 12\t0.13743895\t15299.63431555425m\n * 13\t0.06871947\t7649.817157720176m\n * 14\t0.03435973\t3824.9085788063016m\n * 15\t0.01717986\t1912.4542893462008m\n * 16\t0.00858993\t956.2271446193143m\n * 17\t0.00429496\t478.11357225428907m\n * 18\t0.00214748\t239.05678607177646m\n * 19\t0.00107374\t119.52839298052015m\n * 20\t0.00053687\t59.76419643331005m\n * 21\t0.00026843\t29.882098162868893m\n * 22\t0.00013421\t14.941049026066368m\n * 23\t0.00006710\t7.47052445608316m\n * 24\t0.00003355\t3.735262174255446m\n * 25\t0.00001677\t1.867631030177699m\n * 26\t0.00000838\t0.9338154597207706m\n * 27\t0.00000419\t0.46690767607425154m\n * 28\t0.00000209\t0.233453784250992m\n * 29\t0.00000104\t0.11672683517547201m\n * 30\t5.24287e-7\t0.05836336221965714m\n * 31\t2.62142e-7\t0.02918162257785948m\n * 32\t1.31070e-7\t0.014590754338905755m\n * 33\t6.55349e-8\t0.007295320219428895m\n * 34\t3.27669e-8\t0.0036476047416355755m\n * 35\t1.63829e-8\t0.0018237454207938048m\n * 36\t8.19099e-9\t0.0009118173423180302m\n * 37\t4.09499e-9\t0.0004558533030801429m\n * 38\t2.04701e-9\t0.00022787286540630993m\n * 39\t1.02301e-9\t0.0001138810646242828m\n * 40\t5.10993e-10\t0.00005688358228815859m\n * 41\t2.54999e-10\t0.000028386423065207123m\n * 42\t1.27016e-10\t0.000014139425398842023m\n * 43\t6.30109e-11\t0.00000701434462054884m\n * 44\t3.10080e-11\t0.0000034518042314022482m\n * 45\t1.50066e-11\t0.0000016705340368289525m\n * 46\t6.99174e-12\t7.783169944316711e-7m\n * 47\t3.01270e-12\t3.353723634542973e-7m\n * 48\t9.94759e-13\t1.1073615774434343e-7m\n * \n * @param {number} lat Latitude. Value is clamped to the nearest value in [-90.0, 90.0];\n * @param {number} lng Longitude. Value is wrapped to stay within [-180, 180);\n * @param {number} precision An integer representing the number of bits to take from the \n *                           untruncated latitude and longitude hashes.\n * @returns {string} geohash A binary hash string with a length twice the precision.\n */\nClusterManager.prototype.getGeohash = function(lat, lng, precision) {\n    lat = Math.min(lat, 90.0);\n    lat = Math.max(lat, -90.0);\n    lng = Math.abs((lng+180.0)%360.0) - 180.0;\n\n    if (precision <= 0) return \"\";\n    var max_power = 12; //This is the limit for maximum range of decimal numbers in javascript.\n    // Make the latitude and longitude positive and then mulitiply them by 10^12 to get rid of\n    // as many decimal places as possible. Then change this to binary.\n    var latBase = parseInt((lat + 90.0) * (Math.pow(10, max_power))).toString(2);\n    var lngBase = parseInt((lng + 180.0) * (Math.pow(10, max_power))).toString(2);\n    //Pad the front with zeros to make sure latitude and longitude are 49 bits.\n    var fortyninezeros = \"0000000000000000000000000000000000000000000000000\";\n    var latHash = fortyninezeros.substr(0, 49 - latBase.length) + latBase;\n    var lngHash = fortyninezeros.substr(0, 49 - lngBase.length) + lngBase;\n    //Take bits from the front based on the precision. \n    //Concatinate the latitude and longitude strings.\n    var geohash = latHash.substr(0, precision) + lngHash.substr(0, precision);\n    return geohash;\n};\n\n/**\n * Given a geohash, this returns the bounds on it's range. The inverse of getGeohash.\n * \n * @param {string} geohash A string representing the geobox.\n * @returns {google.maps.LatLngBounds} The bounds on the geobox. \n */\nClusterManager.prototype.geohashGetLatLngBounds = function(geohash) {\n    var max_power = 12;\n    var precision = this.geohashGetPrecision(geohash);\n    var fortyninezeros = \"0000000000000000000000000000000000000000000000000\";\n    var latMinHashBin = geohash.substr(0, precision) + fortyninezeros.substr(0, 49 - precision);\n    var lngMinHashBin = geohash.substr(precision, geohash.length) +\n                        fortyninezeros.substr(0, 49 - precision);\n    var fortynineones = \"1111111111111111111111111111111111111111111111111\";\n    var latMaxHashBin = geohash.substr(0, precision) + fortynineones.substr(0, 49 - precision);\n    var lngMaxHashBin = geohash.substr(precision, geohash.length) +\n                        fortynineones.substr(0, 49 - precision);\n    var latMinHashDec = parseInt(latMinHashBin, 2);\n    var lngMinHashDec = parseInt(lngMinHashBin, 2);\n    var latMaxHashDec = parseInt(latMaxHashBin, 2);\n    var lngMaxHashDec = parseInt(lngMaxHashBin, 2);\n    var latMin = Math.max(-90.0,  (latMinHashDec / Math.pow(10, max_power)) - 90);\n    var lngMin = Math.max(-180.0, (lngMinHashDec / Math.pow(10, max_power)) - 180);\n    var latMax = Math.min(90.0,   (latMaxHashDec / Math.pow(10, max_power)) - 90);\n    var lngMax = Math.min(180.0,  (lngMaxHashDec / Math.pow(10, max_power)) - 180);\n    return new google.maps.LatLngBounds(new google.maps.LatLng(latMin, lngMin), \n                                        new google.maps.LatLng(latMax, lngMax));\n};\n\n/**\n * Derives the precision from a geohash string.\n *\n * @param {string} geohash The geohash to find the precision of.\n * @returns {number} The derived precision of the geobox.\n * @private\n */\nClusterManager.prototype.geohashGetPrecision = function(geohash) {\n    var precision = geohash.length / 2;\n    if (parseInt(precision) !== precision || precision < 0 || precision >= 50) return undefined;\n    return precision;\n};\n\n/**\n * Gets the boxes surrounding the given box and only returns boxes that have at least one marker.\n *\n * @param {string} box_str The geobox to find the neighbors of.\n * @param {string} type The type of the geobox to find the neighbors of.\n * @returns {string[]} The strings for the geoboxes with at least one marker neighboring the input \n * geobox.\n * @private\n */\nClusterManager.prototype.getNeighborBoxes = function(box_str, type) {\n    var bounds = this.geohashGetLatLngBounds(box_str);\n    var precision = this.geohashGetPrecision(box_str);\n    var boxString1 = this.getGeohash(bounds.getSouthWest().lat() + 0.0001, \n                                     bounds.getSouthWest().lng() - 0.0001, precision);\n    var boxString2 = this.getGeohash(bounds.getSouthWest().lat() - 0.0001, \n                                     bounds.getSouthWest().lng() + 0.0001, precision);\n    var boxString3 = this.getGeohash(bounds.getNorthEast().lat() + 0.0001, \n                                     bounds.getNorthEast().lng() - 0.0001, precision);\n    var boxString4 = this.getGeohash(bounds.getNorthEast().lat() - 0.0001, \n                                     bounds.getNorthEast().lng() + 0.0001, precision);\n    var boxString5 = this.getGeohash(bounds.getSouthWest().lat() + 0.0001, \n                                     bounds.getSouthWest().lng() + 0.0001, precision);\n    var boxString6 = this.getGeohash(bounds.getSouthWest().lat() - 0.0001, \n                                     bounds.getSouthWest().lng() - 0.0001, precision);\n    var boxString7 = this.getGeohash(bounds.getNorthEast().lat() + 0.0001, \n                                     bounds.getNorthEast().lng() + 0.0001, precision);\n    var boxString8 = this.getGeohash(bounds.getNorthEast().lat() - 0.0001, \n                                     bounds.getNorthEast().lng() - 0.0001, precision);\n    var boxStrings = [boxString1, boxString2, boxString3, boxString4, boxString5, boxString6, \n                      boxString7, boxString8];\n    for (var i = 0, neighbors = [], boxString; boxString = boxStrings[i]; i++) {\n        if (typeof this.clusters[precision][type][boxString] !== \"undefined\" && boxString !== box_str) {\n            neighbors.push(boxString);\n        }\n    }\n    return neighbors;\n};\n\n/**\n * Given a geohash, this returns a polygon covering the box's bounds. Mostly for debugging to \n * visualize geoboxes.\n *\n * @param {string} geohash A string representing the geobox.\n * @param {object} [opts] Options for the appearance of the polygon.\n * @param {GMap3}  [opts.map=this.map] The map to add the polygon to.\n * @param {string} [opts.strokeColor] \n * @param {string} [opts.strokeWeight]\n * @param {string} [opts.strokeOpacity] \n * @param {string} [opts.fillColor] \n * @param {string} [opts.fillOpacity] .\n * @returns {google.maps.Polygon} A polygon covering the box's bounds.\n */\nClusterManager.prototype.boxToPolygon = function(geohash, opts) {\n    opts = applyDefaults({\n        map           : this.map,\n        strokeColor   : \"#f33f00\",\n        strokeWeight  : 5,\n        strokeOpacity : 1,\n        fillColor     : \"#ff0000\",\n        fillOpacity   : 0.2\n    }, opts);\n    var bounds = this.geohashGetLatLngBounds(geohash);  //TODO:change back!!\n    var ne = bounds.getNorthEast();\n    var sw = bounds.getSouthWest();\n    var polygon = new google.maps.Polygon({\n        paths         : opts.paths || [ne, new google.maps.LatLng(ne.lat(), sw.lng()), sw, \n                         new google.maps.LatLng(sw.lat(), ne.lng()), ne],\n        strokeColor   : opts.strokeColor,\n        strokeWeight  : opts.strokeWeight,\n        strokeOpacity : opts.strokeOpacity,\n        fillColor     : opts.fillColor,\n        fillOpacity   : opts.fillOpacity,\n        map           : opts.map\n    });\n    return polygon;\n};\n\n/**\n * Tests whether a geobox touches a given bounds. Padding expands the range of the bounds based on \n * viewport pixels.\n *\n * @param {string} geohash A string representing the geobox.\n * @param {google.maps.LatLngBounds} bounds The bounds to be tested.\n * @param {number} [padding] The number of pixels to expand the bounds. \n * @returns {boolean} True if any part of the geobox touches the bounds expanded by the padding.\n * @private\n */\nClusterManager.prototype.boxInBounds = function(geohash, bounds, padding) {\n    //make a new LatLngBounds so we don't have any side effects on our map bounds.\n    var newBounds = new google.maps.LatLngBounds(this.map.getBounds().getSouthWest(), \n                                                 this.map.getBounds().getNorthEast());\n    if (typeof padding !== \"undefined\") {\n        var proj = this.map.getProjection();\n        var scale = Math.pow(2, this.map.getZoom());\n        var pixelOffset = new google.maps.Point((padding / scale) || 0, (padding / scale) || 0);\n        var nePoint = proj.fromLatLngToPoint(bounds.getNorthEast());\n        var swPoint = proj.fromLatLngToPoint(bounds.getSouthWest());\n        var newNEPoint = new google.maps.Point(nePoint.x + pixelOffset.x, \n                                               nePoint.y - pixelOffset.y);\n        var newSWPoint = new google.maps.Point(swPoint.x - pixelOffset.x, \n                                               swPoint.y + pixelOffset.y);\n        var newNE = proj.fromPointToLatLng(newNEPoint);\n        var newSW = proj.fromPointToLatLng(newSWPoint);\n        newBounds.extend(newNE);\n        newBounds.extend(newSW);\n    }\n    var boxBounds = this.geohashGetLatLngBounds(geohash);\n    if (newBounds.contains(boxBounds.getNorthEast()) || \n        newBounds.contains(boxBounds.getSouthWest()) || \n        boxBounds.toSpan().lat() === 180) return true;\n    else return false;\n};\n\n/**\n * Use this to add markers in one batch through an array.\n *\n * @param {google.maps.Marker[]} markers An array of markers.\n * @param {string} type The type for the markers being added.\n * @param {string} subtype The subtype for the markers being added.\n */\nClusterManager.prototype.addMarkers = function(markers, type, subtype) {\n    if (Object.prototype.toString.call(markers) === '[object Array]') {\n\n        for(var i=0, length=markers.length; i<length; i++) { \n            var marker = markers[i];\n            this.addMarker(marker, {\n                \"type\"    : type,\n                \"subtype\" : subtype\n            });\n        }\n    }\n};\n\n/**\n * Add a single marker to the map. Stores an associative array for looking for marker types so we \n * can cluster by type. Doesn't build clusters or add them to the map. Each marker can have an opt \n * type and subtype to cluster by. \n *\n * @param {google.maps.Marker} marker The marker to add. \n * @param {object} [opts] Options for the behavior of the marker in the clusters.\n * @param {string} [opts.type] A string that is used to sort which markers to cluster.\n * @param {string} [opts.subtype] A string that is used to show/hide subsets of markers of a given \n * type.\n * @param {boolean} [opts.hidden] Set true to make a marker disappear from the map even if it's in \n * the viewport.\n * @param {boolean} [opts.visible] Set true if the marker is visible in the viewport. \n * @param {string} [opts.summary] The summary text that appears in the cluster's infowindow. \n * Clicking on the text opens the markers infowindow.\n */\nClusterManager.prototype.addMarker = function(raw_marker, opts) {\n    if (typeof opts === \"undefined\") opts = getMarkerMeta(raw_marker);\n\n    var marker = new LazyMarker(raw_marker);\n    \n    //Set when the marker is visible in the viewport and not hidden.\n    //Set when we want to hide the marker even if it's in the viewport.\n    var defaults = {\n        type    : \"generic\",\n        subtype : \"generic\",\n        hidden  : true,\n        visible : false\n    };\n    opts = applyDefaults(defaults, opts);\n    var type = opts.type,\n        subtype = opts.subtype;\n    //if this is the first marker of the type, save the cluster function.\n    if (typeof this.markers[type] === \"undefined\") {\n        this.markers[type] = {};\n        this.cluster_meta[type] = {\n            count: {\n                total   : 0,\n                visible : 0,\n                cluster : 0\n            }\n        };\n    }\n    if (typeof this.cluster_fns[type] === \"undefined\") {\n        this.setClusterFn(type, this.createClusterMarker);\n    }\n    //if this is the first marker of the subtype, set up an empty array to save it in.\n    if (typeof this.markers[type][subtype] === \"undefined\") {\n        this.markers[type][subtype] = [];\n    }\n    this.markers[type][subtype].push(marker);\n    if (subtype !== \"cluster\") {\n        this.cluster_meta[type][\"count\"][\"total\"] += 1;\n        this.addToCluster(marker, type, this.getPrecision());\n    }\n    if (typeof opts.summary === \"undefined\") {\n        var capType = opts.type.charAt(0).toUpperCase() + opts.type.slice(1);\n        opts.summary = typeof marker.getTitle() === \"undefined\" ? capType + \" marker \" +\n                       this.count(opts.type, \"total\") : marker.getTitle();\n    }\n    setMarkerMeta(marker, opts);\n};\n\n/**\n * Returns the number of markers of a particular type.\n *\n * @param {number} type The type of marker to count.\n * @returns {number} The number of markers of a particular type.\n */\nClusterManager.prototype.count = function(type, count_type) {\n    return this.cluster_meta[type][\"count\"][count_type];\n};\n\n/**\n * Adds a marker to a cluster object. Does not create the cluster markers.\n *\n * @param {google.maps.Marker} marker The marker to add. \n * @param {string} type The type of the marker to add. This will be used to form cluster groups. If \n * no type is given it is assigned type \"generic\".\n * @param {number} precision The precision to cluster at.\n * @param {string} [geohash] Force a marker into a particular geobox rather than its default one.\n * @private\n */\nClusterManager.prototype.addToCluster = function(marker, type, precision, geohash) {\n    var clusters = this.clusters;\n    var markerLL = marker.getLatLng();\n    var markerLat = markerLL.latitude;\n    var markerLng = markerLL.longitude;\n    if (typeof clusters[precision] === \"undefined\") {\n        clusters[precision] = {};\n    }\n    if (typeof clusters[precision][type] === \"undefined\") {\n        clusters[precision][type] = {};\n    }\n    var cluster = clusters[precision][type];\n    if (typeof geohash === \"undefined\") {\n        geohash = this.getGeohash(markerLat, markerLng, precision);\n    }\n    if (typeof cluster[geohash] !== \"undefined\") {\n        cluster[geohash][\"markers\"].push(marker);\n        var length = cluster[geohash][\"markers\"].length;\n        var lat = ((length - 1) / length) * cluster[geohash][\"center\"][0] + markerLat / length;\n        var lng = ((length - 1) / length) * cluster[geohash][\"center\"][1] + markerLng / length;\n        cluster[geohash][\"center\"] = [lat, lng];\n    } else {\n        cluster[geohash] = {\n            cluster : false,\n            markers : [marker],\n            center  : [markerLat, markerLng]\n        };\n    }\n};\n\n/**\n * Removes a marker from a cluster and resets the cluster box's properties.\n *\n * @param {google.maps.Marker} marker The marker to remove.\n * @param {string} geohash The geohash to remove the marker from.\n * @private\n */\nClusterManager.prototype.removeFromCluster = function(marker, geohash) {\n    var precision = this.geohashGetPrecision(geohash);\n    var type = getMarkerMeta(marker).type;\n    var geoBox = this.clusters[precision][type][geohash];\n    if (geoBox[\"markers\"].length === 1) {\n        delete(this.clusters[precision][type][geohash]);\n    } else if (geoBox[\"markers\"].length > 1) {\n        for (var i=0, new_markers=[], center_lat=0, center_lng=0, test_marker; \n             test_marker = geoBox[\"markers\"][i]; i++) {\n            if (test_marker !== marker) {\n                new_markers.push(test_marker);\n                center_lat = center_lat + test_marker.getLatLng().latitude;\n                center_lng = center_lng + test_marker.getLatLng().longitude;\n            }\n        }\n        center_lat = center_lat / new_markers.length;\n        center_lng = center_lng / new_markers.length;\n        geoBox[\"center\"] = [center_lat, center_lng];\n        geoBox[\"markers\"] = new_markers;\n        geoBox[\"cluster\"] = false;\n        this.clusters[precision][type][geohash] = geoBox;\n    }\n};\n\n/**\n * This takes two geoboxes and puts all the markers into the one with more markers or the first one.\n * \n * @param {string} box_str1 First box to combine.\n * @param {string} box_str2 Second box to combine.\n * @param {string} type Type of the boxes since this can't be derived.\n * @private\n */\nClusterManager.prototype.combineBoxes = function(box_str1, box_str2, type) {\n    var precision = this.geohashGetPrecision(box_str1);\n    if (this.clusters[precision][type][box_str1][\"markers\"].length < \n        this.clusters[precision][type][box_str2][\"markers\"].length) {\n        var temp = box_str1;\n        box_str1 = box_str2;\n        box_str2 = temp;\n    }\n    var length = this.clusters[precision][type][box_str2][\"markers\"].length;\n    for (var i = length - 1, marker; i >= 0; i--) {\n        marker = this.clusters[precision][type][box_str2][\"markers\"][i];\n        this.removeFromCluster(marker, box_str2);\n        this.addToCluster(marker, type, precision, box_str1);\n    }\n};\n\n/**\n * This checks neighboring geoboxes to see if they are centered within a minimum distance. This \n * makes the clusters less box shaped, but also takes extra time.\n * \n * @param {string} type The type of the markers to cluster.\n * @private\n */\nClusterManager.prototype.combineClustersByDistance = function(type) {\n    var precision = this.getPrecision();\n    var clusters = this.clusters;\n    var clusterDistanceFactor = this.opts.cluster_distance_factor || 2048000;\n    for (var boxStr in clusters[precision][type]) {\n        var neighbors = this.getNeighborBoxes(boxStr, type);\n        var distance = clusterDistanceFactor * Math.pow(2, -precision + 2);\n        var clusterCenter = clusters[precision][type][boxStr][\"center\"];\n/***\n        new google.maps.Circle({\n                strokeColor   : '#FF0000',\n                strokeOpacity : 0.8,\n                strokeWeight  : 2,\n                fillColor     : '#FF0000',\n                fillOpacity   : 0.35,\n                map           : this.map,\n                center        : new google.maps.LatLng(clusterCenter[0], clusterCenter[1]),\n                radius        : distance});\n***/\n        for (var j = 0, result = 0, neighborStr; neighborStr = neighbors[j]; j++) {\n            clusterCenter = clusters[precision][type][boxStr][\"center\"];\n            var neighborCenter = clusters[precision][type][neighborStr][\"center\"];\n            var currentDist = google.maps.geometry.spherical.computeDistanceBetween(\n                              new google.maps.LatLng(clusterCenter[0], clusterCenter[1]), \n                              new google.maps.LatLng(neighborCenter[0], neighborCenter[1]));\n            if (currentDist < distance) {\n                result = j;\n                distance = currentDist;\n            }\n        }\n        if (result) {\n            neighborStr = neighbors[result];\n            this.combineBoxes(boxStr, neighborStr, type);\n        }\n    }\n};\n\n/**\n * This builds the actual cluster markers and optionally combines boxes if the markers get too close \n * together. It does not set up the cluster dictionary.\n *\n * @param {string} [type] The type to cluster. If none is given, this sets up the clusters for every \n * group in the clusterer.\n * @private\n */\nClusterManager.prototype.cluster = function(type) {\n    var precision = this.getPrecision();\n    var clusters,\n        marker,\n        cluster_markers,\n        i;\n    if (typeof type === \"undefined\") {\n        clusters = this.clusters[precision];\n        for (type in clusters) {\n            this.cluster(type);\n        }\n        return;\n    }\n    if (typeof this.markers[type] === \"undefined\") return; //no markers to cluster\n    if (typeof this.markers[type][\"cluster\"] !== \"undefined\") {\n        for (i = 0, marker; marker = this.markers[type][\"cluster\"][i]; i++) {\n            marker.setVisible(false);\n        }\n    }\n    this.markers[type][\"cluster\"] = [];\n    this.cluster_meta[type][\"count\"][\"cluster\"] = 0;\n    clusters = this.clusters;\n    if (this.opts.cluster_by_distance) this.combineClustersByDistance(type);\n    for (var boxStr in clusters[precision][type]) {\n        //visualize the boxes by adding polygons to the map for debugging.\n        if (this.opts.visualize) this.boxToPolygon(boxStr).setMap(this.map);\n        var cluster = clusters[precision][type][boxStr];\n        for (i = 0, cluster_markers = []; marker = cluster[\"markers\"][i]; i++) {\n            var meta = getMarkerMeta(marker);\n            if (typeof meta.hidden === \"undefined\" || !meta.hidden) {\n                cluster_markers.push(marker);\n            }\n        }\n        if (cluster_markers.length > 1) {\n            cluster[\"cluster\"] = this.cluster_fns[type](cluster_markers, cluster[\"center\"][0], \n                                                        cluster[\"center\"][1], this);\n            this.addMarker(cluster[\"cluster\"], {\n                type    : type,\n                subtype : \"cluster\",\n                hidden  : false\n            });\n            this.cluster_meta[type][\"count\"][\"cluster\"] += 1;\n        } else {\n            cluster[\"cluster\"] = false;\n        }\n    }\n};\n\n/**\n * Gets the markers of a given type and/or subtype. Returns all markers if passed no parameters.\n *\n * @param {string} [type] The type of the markers to return.\n * @param {string} [subtype] The subtype of the markers to return.\n * @param {string|boolean} [visible] Pass \"all\" to get markers that aren't clusters.\n                                     Pass true to get all markers that are visible and not hidden.\n * @returns {google.maps.Marker[]} The markers of the given type.\n */\nClusterManager.prototype.getMarkers = function(type, subtype, visible) {\n    var markers = [];\n    if (this.markers === {}) return []; //no markers of any type.\n    if (typeof type === \"undefined\") {\n        for (type in this.markers) {\n            for (subtype in this.markers[type]) {\n                markers = markers.concat(this.markers[type][subtype]);\n            }\n        }\n    } else if (typeof subtype === \"undefined\") {\n        for (subtype in this.markers[type]) {\n            //access all subcategories with a string.\n            markers = markers.concat(this.markers[type][subtype]); \n        }\n    } else {\n        try {\n            markers = this.markers[type][subtype] || [];\n        } catch (err) {\n            markers = [];\n        }\n    }\n    if (typeof visible === \"undefined\") return markers;\n\n    for (var i=0, final_markers=[], length=markers.length; i<length; i++) {\n        var marker = markers[i];\n        var meta = getMarkerMeta(marker);\n        if (visible === \"all\" || meta.hidden !== visible && meta.visible === visible && \n            typeof marker !== \"function\" && meta.type !== \"cluster\") {\n            final_markers.push(marker);\n        }\n    }\n    return final_markers;\n};\n\n/**\n * Handles any change in the map viewport. Calls updateMarkers with a timeout so it doesn't lock up \n * the map.\n * @private\n */\nClusterManager.prototype._onMapMoveEnd = function() {\n    var me = this;\n    if (typeof me.moveTimeout !== \"undefined\") {\n        clearTimeout(me.moveTimeout);\n        delete(me.moveTimeout);\n    }\n    var precision = me.zoomToPrecision(me.map.getZoom());\n    if (me.getPrecision() !== precision) {\n        me.setPrecision(precision);\n    } else {\n        me.moveTimeout = setTimeout(function() {\n            delete(me.moveTimeout);\n            me.updateMarkers();\n        }, 100);\n    }\n};\n\n/**\n * Shows markers of an input type.\n *\n * @param {string} type The type of markers to show.\n * @param {string} subtype The subtype of markers to show.\n */\nClusterManager.prototype.show = function(type, subtype) {\n    this._showHide(type, subtype, false);\n};\n\n/**\n * Hides markers of the input type.\n *\n * @param {string} type The type of markers to hide.\n * @param {string} subtype The subtype of markers to hide.\n */\nClusterManager.prototype.hide = function(type, subtype) {\n    this._showHide(type, subtype, true);\n};\n\n/**\n * Does the actual showing or hiding.\n * @private\n */\nClusterManager.prototype._showHide = function(type, subtype, hide) {\n    var me = this;\n    var markers = this.getMarkers(type, subtype);\n    for(var i=0, length=markers.length; i<length; i++) { \n        var marker = markers[i];\n        getMarkerMeta(marker).hidden = hide;\n    }\n    if (this.ready_) this._lagUpdate(type);\n    else {\n        google.maps.event.addListenerOnce(this, \"ready_\", function() {\n            me._lagUpdate(type);\n        });\n    }\n};\n\n/**\n * Since clustering takes time, this sets up a delay before reclustering.\n * \n * @param {string} type The type to update.\n * @private\n */\nClusterManager.prototype._lagUpdate = function(type) {\n    var me = this;\n    if (typeof this.processingTimeout !== \"undefined\") {\n        clearTimeout(me.processingTimeout);\n        delete(me.processingTimeout);\n    }\n    this.processingTimeout = setTimeout(function() {\n        delete(me.processingTimeout);\n        me.clear(type);\n        me.cluster(type);\n        me.updateMarkers();\n    }, 100);\n};\n\n/**\n * This sets a cluster type to an empty state.\n *\n * @param {string} [type] The type to reset. If none is given, every type in the clusterer is reset.\n */\nClusterManager.prototype.reset = function(type) {\n    if(typeof type === \"undefined\") {\n        var clusters = this.clusters[this.getPrecision()];\n        for(type in clusters) {\n            this.reset(type);\n        }\n        return;\n    }\n    this.clear(type);\n    //this for loop should probably be a reset cluster function\n    for(var precision in this.clusters) {\n        delete(this.clusters[precision][type]);\n        this.clusters[precision][type] = {};\n    }\n    delete(this.markers[type]);\n    this.markers[type] = {};\n};\n\n/**\n * This removes the markers from the map. Use reset if you want to actually get rid of the \n * markers.\n *  \n * @param {string} [type] The type to clear. If it is not passed, all markers managed by the \n * clusterer will be cleared.\n */\nClusterManager.prototype.clear = function(type) {\n    var markers = this.getMarkers(type);\n    for(var i=0, length=markers.length; i<length; i++) { \n        var marker = markers[i];\n        marker.setMap(null);\n        getMarkerMeta(marker).visible = false;\n    }\n    if (typeof type !== \"undefined\" && this.cluster_meta && this.cluster_meta[type]) {\n        this.cluster_meta[type][\"count\"][\"visible\"] = 0;\n    } else {\n        for (var item in this.cluster_meta) {\n            this.cluster_meta[item][\"count\"][\"visible\"] = 0;\n        }\n    }\n};\n\n/**\n * Convert a Google map zoom level to a clusterer precision.\n *\n * @param {number} zoom_level The Google map's zoom level\n * @returns {number} The precision of the input zoom level. \n */\nClusterManager.prototype.zoomToPrecision = function(zoom_level) {\n    return this.opts.zoom_to_precision(zoom_level);\n};\n\n/**\n * Updates the markers on the map based on the current viewport with padding.\n * @private\n */\nClusterManager.prototype.updateMarkers = function() {\n    var marker,\n        meta,\n        length,\n        i;\n    var precision = this.getPrecision();\n    var currentBounds = this.map.getBounds();\n    var cluster = this.clusters[precision];\n    for (var type in cluster) {\n        var type_cluster = cluster[type];\n        for (var box in type_cluster) {\n            var cluster_box = type_cluster[box];\n            var cluster_box_meta = getMarkerMeta(cluster_box[\"cluster\"]);\n            if (this.boxInBounds(box, currentBounds, this.opts.padding)) {\n                if (cluster_box[\"cluster\"]) {\n                    if (!cluster_box_meta.hidden && !cluster_box_meta.visible) {\n                        for(i=0, length=cluster_box[\"markers\"].length; i<length; i++) { \n                            marker = cluster_box[\"markers\"][i];\n                            getMarkerMeta(marker).visible = true;\n                        }\n                        cluster_box[\"cluster\"].setMap(this.map);\n                        cluster_box[\"cluster\"].setVisible(true);\n                        cluster_box_meta.visible = true;\n                        this.cluster_meta[type][\"count\"][\"visible\"] += 1;\n                    }\n                } else {\n                    marker = cluster_box[\"markers\"][0];\n                    meta = getMarkerMeta(marker);\n                    if (!meta.hidden && !meta.visible) {\n                        marker.setMap(this.map);\n                        marker.setVisible(true);\n                        meta.visible = true;\n                        this.cluster_meta[type][\"count\"][\"visible\"] += 1;\n                    }\n                }\n            } else {\n                if (cluster_box[\"cluster\"]) {\n                    cluster_box[\"cluster\"].setVisible(false);\n                    if (cluster_box_meta.visible) this.cluster_meta[type][\"count\"][\"visible\"] -= 1;\n                    cluster_box_meta.visible = false;\n                } else {\n                    for(i=0, length=cluster_box[\"markers\"].length; i<length; i++) { \n                        marker = cluster_box[\"markers\"][i];\n                        meta = getMarkerMeta(marker);\n                        marker.setVisible(false);\n                        if (meta.visible) this.cluster_meta[type][\"count\"][\"visible\"] -= 1;\n                        meta.visible = false;\n                    }\n                }\n            }\n        }\n    }\n};\n\n/**\n * Sets the clustering function for a given type of markers. \n * \n * @param {string} type The type the clustering function is set up for.\n * @param {function} fn The function that is used to cluster the markers. See\n *                      ClusterManager.createClusterMarker for an example of\n *                      its parameters and return value.\n */\nClusterManager.prototype.setClusterFn = function(type, fn) {\n    this.cluster_fns[type] = fn;\n};\n\n/**\n * A free function for creating cluster icons. At precisions greater than 10, the markers will be\n * precise looking pins. At precisions less then 10, the markers will be circles that float above\n * the map.\n * \n * @param {number} number The number of markers in the cluster.\n * @param {number} precision The precision of markers.\n * @param {string} icon_color A HEX color for the marker.\n * @param {string} [text_color=\"000000\"] A HEX color for the text inside the markers.\n * @returns {object} An object containing the configuration options for a cluster icon.\n */\nClusterManager.prototype.createClusterIcon = function(number, precision, icon_color, text_color) {\n    var iconOpts;\n    text_color = text_color || \"000000\";\n    if (precision > 10) {\n        iconOpts = {\n            \"url\"  : 'http://chart.apis.google.com/chart?cht=d&chdp=mapsapi&chl=pin%27i\\\\%27[' + \n                      number + '%27-2%27f\\\\hv%27a\\\\]h\\\\]o\\\\' + icon_color + '%27fC\\\\' + text_color + \n                      '%27tC\\\\000000%27eC\\\\Lauto%27f\\\\&ext=.png',\n            \"size\" : new google.maps.Size(21, 34)\n        };\n    } else {\n        var size = ((number + \"\").length - 1) * 6 + 24;\n        iconOpts = {\n            \"size\"   : new google.maps.Size(size, size),\n            \"anchor\" : new google.maps.Point(size/2, size/2),\n            \"shape\"  : {\n                coord : [size/2, size/2, size/2],\n                type  : \"circle\"\n            },\n            \"url\"    : \"http://chart.apis.google.com/chart?cht=it&chs=\" + size + \"x\" + size +\n                       \"&chco=\" + icon_color + \",000000ff,ffffff01&chl=\" + number + \"&chx=\" + \n                        text_color + \",0&chf=bg,s,00000000&ext=.png\"\n        };\n    }\n    return this.createMarkerIconOpts(iconOpts);\n};\n\n/**\n * A free function for creating cluster markers.\n * \n * @param {google.maps.Marker[]} marker_list An array of markers to make a cluster icon for.\n * @param {number} center_lat The center latitude of the cluster.\n * @param {number} center_lng The center longitude of the cluster.\n * @param {ClusterManager} manager The ClusterManager object managing the cluster.\n * @returns {google.maps.Marker} The new cluster marker.\n */\nClusterManager.prototype.createClusterMarker = function(marker_list, center_lat, center_lng, manager) {\n    var htmlEl = document.createElement(\"div\");\n    htmlEl.style.width = \"400px\";\n\n    function markerClickClosure(marker) {\n        return function(e) {\n            google.maps.event.trigger(marker, \"click\", e);\n        };\n    }\n    for (var i = 0, marker; marker = marker_list[i]; i++) {\n        var markerSpan = document.createElement(\"span\");\n        markerSpan.innerHTML = '<b>' + getMarkerMeta(marker).summary + '</b><br>';\n        markerSpan.onclick = markerClickClosure(marker);\n        markerSpan.style.color = \"#334499\";\n        markerSpan.style.cursor = \"pointer\";\n        htmlEl.appendChild(markerSpan);\n        if (i >= 9) break;\n    }\n    if (marker_list.length > 10) {\n        htmlEl.appendChild(document.createTextNode((marker_list.length - 10) + \n                           \" more markers in this area. Zoom in for details.\"));\n    }\n    var icon_color = manager.opts.icon_color[getMarkerMeta(marker_list[0]).type] || \n                                                                   manager.opts.icon_color;\n    var icon = manager.createClusterIcon(marker_list.length, manager.getPrecision(), icon_color);\n    marker = manager.createMarker({\n        \"position\" : new google.maps.LatLng(center_lat, center_lng),\n        \"title\"    : marker_list.length + \" markers\",\n        \"content\"  : htmlEl,\n        \"summary\"  : marker_list.length + \" markers\",\n        \"icon\"     : icon,\n        \"shape\"    : icon[\"shape\"],\n        \"zIndex\"   : marker_list.length\n    });\n    return marker;\n};\n\n/**\n * A free function for creating marker icon opts.\n * \n * @param {object} [opts] Options for configuring the appearance of the marker icon.\n * @param {number} [opts.width=32] The width of the icon.\n * @param {number} [opts.height=32] The height of the icon.\n * @param {string|object} [opts.icon_color=\"ff0000\"] The HEX color of the icon or an associate array \n * with a color for corresponding marker types.\n * @param {string} [opts.type] A type for the marker.\n * @param {string} [opts.strokeColor=\"000000\"] The HEX color for icon's stroke.\n * @param {string} [opts.cornerColor=\"ffffff\"] The HEX color for icon's corner.\n * @returns {object} An object that can be used to create a map icon.\n */\nClusterManager.prototype.createMarkerIconOpts = function(opts) {\n    if (typeof opts === \"undefined\") opts = {};\n    \n    var default_icon_color = \"ff0000\";\n    if (typeof this.opts !== \"undefined\" && typeof this.opts.icon_color !== \"undefined\") {\n        if (typeof this.opts.icon_color === \"string\") {\n            default_icon_color = this.opts.icon_color;\n        } else if (typeof this.opts.icon_color === \"object\" && typeof opts.type !== \"undefined\" && typeof this.opts.icon_color[opts.type] === \"string\") {\n            default_icon_color = this.opts.icon_color[opts.type];\n        }\n    } \n\n    return createMarkerIconOpts(applyDefaults({icon_color: default_icon_color}, opts));\n};\n\n/**\n * A free function for creating markers. In addition to the parameters below, you can pass any \n * option listed in Google's reference:\n * https://developers.google.com/maps/documentation/javascript/reference#MarkerOptions\n * \n * @param {object} [opts] Options for configuring the marker. \n * @param {google.maps.Map} [opts.map=this.map] The map on which to display the marker. \n * @param {boolean} [opts.visible=false] Make the marker visible initially.\n * @param {object} [opts.icon=this.createMarkerIconOpts(opts)] The marker's icon.\n * @param {function} [opts.fn] A function called when the marker is clicked.\n * @param {string} [opts.content=\"Marker\"] If the marker does not have opts.fn defined, this \n * determines the content of the infowindow displayed when the marker is clicked.\n */\nClusterManager.prototype.createMarker = function(opts) {\n    return createMarker(this.map, \n                        applyDefaults({icon: this.createMarkerIconOpts(opts)}, opts));\n};\n\n\n\n//export default ClusterManager;",null,"'use strict';\nimport applyDefaults from './utils';\n\n//var applyDefaults = require('./utils');\n\nfunction LazyMarker(raw_marker) {\n    this.raw_marker = raw_marker;\n    if (typeof raw_marker.setMap === \"function\") {\n        this._marker = raw_marker;\n    } else {\n        this._marker = null;\n    }\n    google.maps.event.addListener(this, \"click\", function (e) {\n        if (this._marker) {\n            google.maps.event.trigger(this._marker, \"click\", e);\n        }\n    });\n}\n\nLazyMarker.prototype.setMap = function (map) {\n    if (this._marker) {\n        this._marker.setMap(map);\n        return;\n    }\n    if (!map) return;\n\n    var defaults = {\n        title: this.raw_marker.title,\n        type: false,\n        subtype: \"\",\n        content: \"\"\n    };\n    var opts = applyDefaults(defaults, this.raw_marker);\n\n    this._marker = ClusterManager.prototype.createMarker({\n        title: opts.title,\n        type: opts.type,\n        content: opts.content,\n        position: new google.maps.LatLng(opts.latitutde,\n                                        opts.longitude),\n        subtype: opts.subtype\n    });\n\n    this._marker.setMap(map);\n};\n\nLazyMarker.prototype.getPosition = function () {\n    if (this._marker && this._marker.getPosition()) {\n        return this._marker.getPosition();\n    }\n    var latlng = this.getLatLng();\n    this.raw_marker.position = new google.maps.LatLng(latlng.latitutde, latlng.longitude);\n    return this.raw_marker.position;\n};\n\nLazyMarker.prototype.getLatLng = function () {\n    if (this._marker && typeof this.raw_marker.latitude === \"undefined\") {\n        this.raw_marker.position = this._marker.getPosition();\n        this.raw_marker.latitude = this.raw_marker.position.lat();\n        this.raw_marker.longitude = this.raw_marker.position.lng();\n    }\n    return {\n        latitude: this.raw_marker.latitude,\n        longitude: this.raw_marker.longitude\n    };\n};\n\nLazyMarker.prototype.getTitle = function () {\n    return (this._marker && this._marker.getTitle()) || this.raw_marker.title;\n};\n\nLazyMarker.prototype.setVisible = function (visible) {\n    this._marker && this._marker.setVisible(visible);\n};\n\n//module.exports = LazyMarker;\nexport default LazyMarker;\n//window.LazyMarker = LazyMarker;","'use strict';\n\n/**\n * Tool for applying defaults. Any property in defaults will be overwritten by a corresponding\n * property in opts. If the property does not exist, the default remains. Only properties in \n * defaults will be included in the final object.\n * \n * @param {object} [defaults]\n * @param {object} [opts]\n * @returns {object} \n */\n export function applyDefaults(defaults, opts) {\n    if (typeof defaults !== \"object\") return {};\n    if (typeof opts !== \"object\") return defaults;\n    for (var index in defaults) {\n        if (typeof opts[index] === \"undefined\") {\n            opts[index] = defaults[index];\n        }\n    }\n    return opts;\n}\n     \n/**\n * Sets a marker's meta properties. Properties already set are treated as defaults.\n * \n * @param {google.maps.Marker} marker\n * @param {object} meta\n */\nexport function setMarkerMeta(marker, meta) {\n    var defaults = applyDefaults(meta, marker._cluster_meta);\n    marker._cluster_meta = applyDefaults(defaults, meta);\n}   \n\n/**\n * Gets a marker's meta properties.\n * \n * @param {google.maps.Marker} marker\n * @returns {object} The object with extra data about the marker.\n */\n export function getMarkerMeta(marker) {\n    try {\n        return marker._cluster_meta;\n    } catch (err) {\n        marker._cluster_meta = {};\n        return marker._cluster_meta;\n    }\n}\n\n/**\n * A free function for creating marker icon opts.\n * \n * @param {object} [opts] Options for configuring the appearance of the marker icon.\n * @param {number} [opts.width=32] The width of the icon.\n * @param {number} [opts.height=32] The height of the icon.\n * @param {string|object} [opts.icon_color=\"ff0000\"] The HEX color of the icon or an associate array \n * with a color for corresponding marker types.\n * @param {string} [opts.type] A type for the marker.\n * @param {string} [opts.strokeColor=\"000000\"] The HEX color for icon's stroke.\n * @param {string} [opts.cornerColor=\"ffffff\"] The HEX color for icon's corner.\n * @returns {object} An object that can be used to create a map icon.\n */\nexport function createMarkerIconOpts(opts) {\n    if (typeof opts === \"undefined\") opts = {};\n    if (typeof opts.width === \"undefined\") opts.width = 32;\n    if (typeof opts.height === \"undefined\") opts.height = 32;\n    var width = opts.width,\n        height = opts.height;\n    \n    var icon_color = \"ff0000\";\n    // 1. opts.icon_color[opts.type]\n    // 2. opts.icon_color\n    // 3. mgr opts.icon_color[opts.type]\n    // 3a. mgr opts.icon_color[opts.type] === undefined => \"ff0000\"\n    // 4. mgr opts.icon_color\n    // 5. \"ff0000\"\n    if (typeof opts.icon_color !== \"undefined\") {\n        if (typeof opts.icon_color === \"string\") {\n            icon_color = opts.icon_color;\n        } else if (typeof opts.icon_color === \"object\" && typeof opts.type !== \"undefined\" && typeof opts.icon_color[opts.type] === \"string\") {\n            icon_color = opts.icon_color[opts.type];            \n        }\n    }\n\n    if (typeof opts.strokeColor === \"undefined\") opts.strokeColor = \"000000\";\n    if (typeof opts.cornerColor === \"undefined\") opts.cornerColor = \"ffffff\";\n    var baseUrl = \"http://chart.apis.google.com/chart?cht=mm\";\n    var iconUrl = baseUrl + \"&chs=\" + width + \"x\" + height + \"&chco=\" +\n                 opts.cornerColor.replace(\"#\", \"\") + \",\" + icon_color + \",\" +\n                 opts.strokeColor.replace(\"#\", \"\") + \"&ext=.png\";\n\n    return applyDefaults({\n        url    : iconUrl,\n        size   : new google.maps.Size(width, height),\n        origin : new google.maps.Point(0, 0),\n        anchor : new google.maps.Point(width/2, height)\n    }, opts);\n}\n\n\n/**\n * A free function for creating markers. In addition to the parameters below, you can pass any \n * option listed in Google's reference:\n * https://developers.google.com/maps/documentation/javascript/reference#MarkerOptions\n * \n * @param {object} [opts] Options for configuring the marker. \n * @param {google.maps.Map} [opts.map=this.map] The map on which to display the marker. \n * @param {boolean} [opts.visible=false] Make the marker visible initially.\n * @param {object} [opts.icon=this.createMarkerIconOpts(opts)] The marker's icon.\n * @param {function} [opts.fn] A function called when the marker is clicked.\n * @param {string} [opts.content=\"Marker\"] If the marker does not have opts.fn defined, this \n * determines the content of the infowindow displayed when the marker is clicked.\n */\n export function createMarker(map, opts) {\n //   var defaultIconOpts = this.createMarkerIconOpts(opts);\n    var defaults = {\n        map     : map,\n        visible : false,\n        icon    : createMarkerIconOpts(opts),\n        content : \"Marker\"\n    };\n    opts = applyDefaults(defaults, opts);\n    var marker = new google.maps.Marker(opts);\n    if (typeof opts.fn === \"undefined\") {\n        var iw = new google.maps.InfoWindow({\n            content: opts.content\n        });\n        google.maps.event.addListener(marker, 'click', function() {\n            var now = new Date();\n            iw.setZIndex(now.getTime());\n            iw.open(map, marker);\n        });\n    } else {\n        google.maps.event.addListener(marker, 'click', opts.fn);\n    }\n    setMarkerMeta(marker, opts);\n    return marker;\n}\n \n//export applyDefaults;"],"sourceRoot":"/source/"}